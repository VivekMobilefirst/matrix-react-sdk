{"version":3,"file":"SecurityManager.js","names":["secretStorageKeys","secretStorageKeyInfo","secretStorageBeingAccessed","nonInteractive","dehydrationCache","isCachingAllowed","isSecretStorageBeingAccessed","AccessCancelledError","Error","constructor","confirmToDismiss","sure","Modal","createDialog","QuestionDialog","title","_t","description","danger","button","cancelButton","finished","makeInputToKey","keyInfo","passphrase","recoveryKey","deriveKey","salt","iterations","decodeRecoveryKey","getSecretStorageKey","keys","keyInfos","cli","MatrixClientPeg","get","keyId","getDefaultSecretStorageKeyId","undefined","keyInfoEntries","Object","entries","length","key","checkSecretStorageKey","cacheSecretStorageKey","keyFromCustomisations","SecurityCustomisations","logger","log","inputToKey","AccessSecretStorageDialog","checkPrivateKey","input","onBeforeClose","reason","keyParams","getDehydrationKey","checkFunc","e","Uint8Array","onSecretRequested","userId","deviceId","requestId","name","deviceTrust","client","getUserId","isVerified","callbacks","getCrossSigningCacheCallbacks","getCrossSigningKeyCache","replace","encodeBase64","crypto","getSessionBackupPrivateKey","warn","crossSigningCallbacks","promptForBackupPassphrase","RestoreKeyBackupDialog","showSummary","keyCallback","k","success","accessSecretStorage","func","forceReset","hasSecretStorageKey","createDialogAsync","isSecureBackupRequired","confirmed","bootstrapCrossSigning","authUploadDeviceSigningKeys","makeRequest","InteractiveAuthDialog","matrixClient","bootstrapSecretStorage","getKeyBackupPassphrase","SettingsStore","getValue","dehydrationKeyInfo","setDehydrationKey","catchAccessSecretStorageError","error","tryToUnlockSecretStorageWithDehydrationKey","restoringBackup","isSecretStorageReady","checkOwnCrossSigningTrust","backupInfo","getKeyBackupVersion","restoreKeyBackupWithSecretStorage","finally"],"sources":["../src/SecurityManager.ts"],"sourcesContent":["/*\nCopyright 2019, 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { ICryptoCallbacks } from 'matrix-js-sdk/src/matrix';\nimport { ISecretStorageKeyInfo } from 'matrix-js-sdk/src/crypto/api';\nimport { MatrixClient } from 'matrix-js-sdk/src/client';\nimport { deriveKey } from 'matrix-js-sdk/src/crypto/key_passphrase';\nimport { decodeRecoveryKey } from 'matrix-js-sdk/src/crypto/recoverykey';\nimport { encodeBase64 } from \"matrix-js-sdk/src/crypto/olmlib\";\nimport { DeviceTrustLevel } from 'matrix-js-sdk/src/crypto/CrossSigning';\nimport { logger } from \"matrix-js-sdk/src/logger\";\nimport { ComponentType } from \"react\";\n\nimport Modal from './Modal';\nimport { MatrixClientPeg } from './MatrixClientPeg';\nimport { _t } from './languageHandler';\nimport { isSecureBackupRequired } from './utils/WellKnownUtils';\nimport AccessSecretStorageDialog from './components/views/dialogs/security/AccessSecretStorageDialog';\nimport RestoreKeyBackupDialog from './components/views/dialogs/security/RestoreKeyBackupDialog';\nimport SettingsStore from \"./settings/SettingsStore\";\nimport SecurityCustomisations from \"./customisations/Security\";\nimport QuestionDialog from \"./components/views/dialogs/QuestionDialog\";\nimport InteractiveAuthDialog from \"./components/views/dialogs/InteractiveAuthDialog\";\n\n// This stores the secret storage private keys in memory for the JS SDK. This is\n// only meant to act as a cache to avoid prompting the user multiple times\n// during the same single operation. Use `accessSecretStorage` below to scope a\n// single secret storage operation, as it will clear the cached keys once the\n// operation ends.\nlet secretStorageKeys: Record<string, Uint8Array> = {};\nlet secretStorageKeyInfo: Record<string, ISecretStorageKeyInfo> = {};\nlet secretStorageBeingAccessed = false;\n\nlet nonInteractive = false;\n\nlet dehydrationCache: {\n    key?: Uint8Array;\n    keyInfo?: ISecretStorageKeyInfo;\n} = {};\n\nfunction isCachingAllowed(): boolean {\n    return secretStorageBeingAccessed;\n}\n\n/**\n * This can be used by other components to check if secret storage access is in\n * progress, so that we can e.g. avoid intermittently showing toasts during\n * secret storage setup.\n *\n * @returns {bool}\n */\nexport function isSecretStorageBeingAccessed(): boolean {\n    return secretStorageBeingAccessed;\n}\n\nexport class AccessCancelledError extends Error {\n    constructor() {\n        super(\"Secret storage access canceled\");\n    }\n}\n\nasync function confirmToDismiss(): Promise<boolean> {\n    const [sure] = await Modal.createDialog(QuestionDialog, {\n        title: _t(\"Cancel entering passphrase?\"),\n        description: _t(\"Are you sure you want to cancel entering passphrase?\"),\n        danger: false,\n        button: _t(\"Go Back\"),\n        cancelButton: _t(\"Cancel\"),\n    }).finished;\n    return !sure;\n}\n\ntype KeyParams = { passphrase: string, recoveryKey: string };\n\nfunction makeInputToKey(\n    keyInfo: ISecretStorageKeyInfo,\n): (keyParams: KeyParams) => Promise<Uint8Array> {\n    return async ({ passphrase, recoveryKey }) => {\n        if (passphrase) {\n            return deriveKey(\n                passphrase,\n                keyInfo.passphrase.salt,\n                keyInfo.passphrase.iterations,\n            );\n        } else {\n            return decodeRecoveryKey(recoveryKey);\n        }\n    };\n}\n\nasync function getSecretStorageKey(\n    { keys: keyInfos }: { keys: Record<string, ISecretStorageKeyInfo> },\n): Promise<[string, Uint8Array]> {\n    const cli = MatrixClientPeg.get();\n    let keyId = await cli.getDefaultSecretStorageKeyId();\n    let keyInfo: ISecretStorageKeyInfo;\n    if (keyId) {\n        // use the default SSSS key if set\n        keyInfo = keyInfos[keyId];\n        if (!keyInfo) {\n            // if the default key is not available, pretend the default key\n            // isn't set\n            keyId = undefined;\n        }\n    }\n    if (!keyId) {\n        // if no default SSSS key is set, fall back to a heuristic of using the\n        // only available key, if only one key is set\n        const keyInfoEntries = Object.entries(keyInfos);\n        if (keyInfoEntries.length > 1) {\n            throw new Error(\"Multiple storage key requests not implemented\");\n        }\n        [keyId, keyInfo] = keyInfoEntries[0];\n    }\n\n    // Check the in-memory cache\n    if (isCachingAllowed() && secretStorageKeys[keyId]) {\n        return [keyId, secretStorageKeys[keyId]];\n    }\n\n    if (dehydrationCache.key) {\n        if (await MatrixClientPeg.get().checkSecretStorageKey(dehydrationCache.key, keyInfo)) {\n            cacheSecretStorageKey(keyId, keyInfo, dehydrationCache.key);\n            return [keyId, dehydrationCache.key];\n        }\n    }\n\n    const keyFromCustomisations = SecurityCustomisations.getSecretStorageKey?.();\n    if (keyFromCustomisations) {\n        logger.log(\"Using key from security customisations (secret storage)\");\n        cacheSecretStorageKey(keyId, keyInfo, keyFromCustomisations);\n        return [keyId, keyFromCustomisations];\n    }\n\n    if (nonInteractive) {\n        throw new Error(\"Could not unlock non-interactively\");\n    }\n\n    const inputToKey = makeInputToKey(keyInfo);\n    const { finished } = Modal.createDialog(\n        AccessSecretStorageDialog,\n        /* props= */\n        {\n            keyInfo,\n            checkPrivateKey: async (input: KeyParams) => {\n                const key = await inputToKey(input);\n                return MatrixClientPeg.get().checkSecretStorageKey(key, keyInfo);\n            },\n        },\n        /* className= */ null,\n        /* isPriorityModal= */ false,\n        /* isStaticModal= */ false,\n        /* options= */ {\n            onBeforeClose: async (reason) => {\n                if (reason === \"backgroundClick\") {\n                    return confirmToDismiss();\n                }\n                return true;\n            },\n        },\n    );\n    const [keyParams] = await finished;\n    if (!keyParams) {\n        throw new AccessCancelledError();\n    }\n    const key = await inputToKey(keyParams);\n\n    // Save to cache to avoid future prompts in the current session\n    cacheSecretStorageKey(keyId, keyInfo, key);\n\n    return [keyId, key];\n}\n\nexport async function getDehydrationKey(\n    keyInfo: ISecretStorageKeyInfo,\n    checkFunc: (Uint8Array) => void,\n): Promise<Uint8Array> {\n    const keyFromCustomisations = SecurityCustomisations.getSecretStorageKey?.();\n    if (keyFromCustomisations) {\n        logger.log(\"Using key from security customisations (dehydration)\");\n        return keyFromCustomisations;\n    }\n\n    const inputToKey = makeInputToKey(keyInfo);\n    const { finished } = Modal.createDialog(\n        AccessSecretStorageDialog,\n        /* props= */\n        {\n            keyInfo,\n            checkPrivateKey: async (input) => {\n                const key = await inputToKey(input);\n                try {\n                    checkFunc(key);\n                    return true;\n                } catch (e) {\n                    return false;\n                }\n            },\n        },\n        /* className= */ null,\n        /* isPriorityModal= */ false,\n        /* isStaticModal= */ false,\n        /* options= */ {\n            onBeforeClose: async (reason) => {\n                if (reason === \"backgroundClick\") {\n                    return confirmToDismiss();\n                }\n                return true;\n            },\n        },\n    );\n    const [input] = await finished;\n    if (!input) {\n        throw new AccessCancelledError();\n    }\n    const key = await inputToKey(input);\n\n    // need to copy the key because rehydration (unpickling) will clobber it\n    dehydrationCache = { key: new Uint8Array(key), keyInfo };\n\n    return key;\n}\n\nfunction cacheSecretStorageKey(\n    keyId: string,\n    keyInfo: ISecretStorageKeyInfo,\n    key: Uint8Array,\n): void {\n    if (isCachingAllowed()) {\n        secretStorageKeys[keyId] = key;\n        secretStorageKeyInfo[keyId] = keyInfo;\n    }\n}\n\nasync function onSecretRequested(\n    userId: string,\n    deviceId: string,\n    requestId: string,\n    name: string,\n    deviceTrust: DeviceTrustLevel,\n): Promise<string> {\n    logger.log(\"onSecretRequested\", userId, deviceId, requestId, name, deviceTrust);\n    const client = MatrixClientPeg.get();\n    if (userId !== client.getUserId()) {\n        return;\n    }\n    if (!deviceTrust?.isVerified()) {\n        logger.log(`Ignoring secret request from untrusted device ${deviceId}`);\n        return;\n    }\n    if (\n        name === \"m.cross_signing.master\" ||\n        name === \"m.cross_signing.self_signing\" ||\n        name === \"m.cross_signing.user_signing\"\n    ) {\n        const callbacks = client.getCrossSigningCacheCallbacks();\n        if (!callbacks.getCrossSigningKeyCache) return;\n        const keyId = name.replace(\"m.cross_signing.\", \"\");\n        const key = await callbacks.getCrossSigningKeyCache(keyId);\n        if (!key) {\n            logger.log(\n                `${keyId} requested by ${deviceId}, but not found in cache`,\n            );\n        }\n        return key && encodeBase64(key);\n    } else if (name === \"m.megolm_backup.v1\") {\n        const key = await client.crypto.getSessionBackupPrivateKey();\n        if (!key) {\n            logger.log(\n                `session backup key requested by ${deviceId}, but not found in cache`,\n            );\n        }\n        return key && encodeBase64(key);\n    }\n    logger.warn(\"onSecretRequested didn't recognise the secret named \", name);\n}\n\nexport const crossSigningCallbacks: ICryptoCallbacks = {\n    getSecretStorageKey,\n    cacheSecretStorageKey,\n    onSecretRequested,\n    getDehydrationKey,\n};\n\nexport async function promptForBackupPassphrase(): Promise<Uint8Array> {\n    let key: Uint8Array;\n\n    const { finished } = Modal.createDialog(RestoreKeyBackupDialog, {\n        showSummary: false, keyCallback: k => key = k,\n    }, null, /* priority = */ false, /* static = */ true);\n\n    const success = await finished;\n    if (!success) throw new Error(\"Key backup prompt cancelled\");\n\n    return key;\n}\n\n/**\n * This helper should be used whenever you need to access secret storage. It\n * ensures that secret storage (and also cross-signing since they each depend on\n * each other in a cycle of sorts) have been bootstrapped before running the\n * provided function.\n *\n * Bootstrapping secret storage may take one of these paths:\n * 1. Create secret storage from a passphrase and store cross-signing keys\n *    in secret storage.\n * 2. Access existing secret storage by requesting passphrase and accessing\n *    cross-signing keys as needed.\n * 3. All keys are loaded and there's nothing to do.\n *\n * Additionally, the secret storage keys are cached during the scope of this function\n * to ensure the user is prompted only once for their secret storage\n * passphrase. The cache is then cleared once the provided function completes.\n *\n * @param {Function} [func] An operation to perform once secret storage has been\n * bootstrapped. Optional.\n * @param {bool} [forceReset] Reset secret storage even if it's already set up\n */\nexport async function accessSecretStorage(func = async () => { }, forceReset = false) {\n    const cli = MatrixClientPeg.get();\n    secretStorageBeingAccessed = true;\n    try {\n        if (!(await cli.hasSecretStorageKey()) || forceReset) {\n            // This dialog calls bootstrap itself after guiding the user through\n            // passphrase creation.\n            const { finished } = Modal.createDialogAsync(\n                import(\n                    \"./async-components/views/dialogs/security/CreateSecretStorageDialog\"\n                ) as unknown as Promise<ComponentType<{}>>,\n                {\n                    forceReset,\n                },\n                null,\n                /* priority = */ false,\n                /* static = */ true,\n                /* options = */ {\n                    onBeforeClose: async (reason) => {\n                        // If Secure Backup is required, you cannot leave the modal.\n                        if (reason === \"backgroundClick\") {\n                            return !isSecureBackupRequired();\n                        }\n                        return true;\n                    },\n                },\n            );\n            const [confirmed] = await finished;\n            if (!confirmed) {\n                throw new Error(\"Secret storage creation canceled\");\n            }\n        } else {\n            await cli.bootstrapCrossSigning({\n                authUploadDeviceSigningKeys: async (makeRequest) => {\n                    const { finished } = Modal.createDialog(InteractiveAuthDialog, {\n                        title: _t(\"Setting up keys\"),\n                        matrixClient: cli,\n                        makeRequest,\n                    });\n                    const [confirmed] = await finished;\n                    if (!confirmed) {\n                        throw new Error(\"Cross-signing key upload auth canceled\");\n                    }\n                },\n            });\n            await cli.bootstrapSecretStorage({\n                getKeyBackupPassphrase: promptForBackupPassphrase,\n            });\n\n            const keyId = Object.keys(secretStorageKeys)[0];\n            if (keyId && SettingsStore.getValue(\"feature_dehydration\")) {\n                let dehydrationKeyInfo = {};\n                if (secretStorageKeyInfo[keyId] && secretStorageKeyInfo[keyId].passphrase) {\n                    dehydrationKeyInfo = { passphrase: secretStorageKeyInfo[keyId].passphrase };\n                }\n                logger.log(\"Setting dehydration key\");\n                await cli.setDehydrationKey(secretStorageKeys[keyId], dehydrationKeyInfo, \"Backup device\");\n            } else if (!keyId) {\n                logger.warn(\"Not setting dehydration key: no SSSS key found\");\n            } else {\n                logger.log(\"Not setting dehydration key: feature disabled\");\n            }\n        }\n\n        // `return await` needed here to ensure `finally` block runs after the\n        // inner operation completes.\n        return await func();\n    } catch (e) {\n        SecurityCustomisations.catchAccessSecretStorageError?.(e);\n        logger.error(e);\n        // Re-throw so that higher level logic can abort as needed\n        throw e;\n    } finally {\n        // Clear secret storage key cache now that work is complete\n        secretStorageBeingAccessed = false;\n        if (!isCachingAllowed()) {\n            secretStorageKeys = {};\n            secretStorageKeyInfo = {};\n        }\n    }\n}\n\n// FIXME: this function name is a bit of a mouthful\nexport async function tryToUnlockSecretStorageWithDehydrationKey(\n    client: MatrixClient,\n): Promise<void> {\n    const key = dehydrationCache.key;\n    let restoringBackup = false;\n    if (key && (await client.isSecretStorageReady())) {\n        logger.log(\"Trying to set up cross-signing using dehydration key\");\n        secretStorageBeingAccessed = true;\n        nonInteractive = true;\n        try {\n            await client.checkOwnCrossSigningTrust();\n\n            // we also need to set a new dehydrated device to replace the\n            // device we rehydrated\n            let dehydrationKeyInfo = {};\n            if (dehydrationCache.keyInfo && dehydrationCache.keyInfo.passphrase) {\n                dehydrationKeyInfo = { passphrase: dehydrationCache.keyInfo.passphrase };\n            }\n            await client.setDehydrationKey(key, dehydrationKeyInfo, \"Backup device\");\n\n            // and restore from backup\n            const backupInfo = await client.getKeyBackupVersion();\n            if (backupInfo) {\n                restoringBackup = true;\n                // don't await, because this can take a long time\n                client.restoreKeyBackupWithSecretStorage(backupInfo)\n                    .finally(() => {\n                        secretStorageBeingAccessed = false;\n                        nonInteractive = false;\n                        if (!isCachingAllowed()) {\n                            secretStorageKeys = {};\n                            secretStorageKeyInfo = {};\n                        }\n                    });\n            }\n        } finally {\n            dehydrationCache = {};\n            // the secret storage cache is needed for restoring from backup, so\n            // don't clear it yet if we're restoring from backup\n            if (!restoringBackup) {\n                secretStorageBeingAccessed = false;\n                nonInteractive = false;\n                if (!isCachingAllowed()) {\n                    secretStorageKeys = {};\n                    secretStorageKeyInfo = {};\n                }\n            }\n        }\n    }\n}\n"],"mappings":"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"}