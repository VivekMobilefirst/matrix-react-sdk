{"version":3,"file":"Singleflight.js","names":["keyMap","EnhancedMap","Singleflight","constructor","for","instance","key","Error","SingleflightContext","forgetAllFor","delete","forgetAll","k","keys","remove","Symbol","forget","map","get","size","do","fn","getOrCreate","val","undefined","set"],"sources":["../../src/utils/Singleflight.ts"],"sourcesContent":["/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { EnhancedMap } from \"./maps\";\n\n// Inspired by https://pkg.go.dev/golang.org/x/sync/singleflight\n\nconst keyMap = new EnhancedMap<Object, EnhancedMap<string, unknown>>();\n\n/**\n * Access class to get a singleflight context. Singleflights execute a\n * function exactly once, unless instructed to forget about a result.\n *\n * Typically this is used to de-duplicate an action, such as a save button\n * being pressed, without having to track state internally for an operation\n * already being in progress. This doesn't expose a flag which can be used\n * to disable a button, however it would be capable of returning a Promise\n * from the first call.\n *\n * The result of the function call is cached indefinitely, just in case a\n * second call comes through late. There are various functions named \"forget\"\n * to have the cache be cleared of a result.\n *\n * Singleflights in our use case are tied to an instance of something, combined\n * with a string key to differentiate between multiple possible actions. This\n * means that a \"save\" key will be scoped to the instance which defined it and\n * not leak between other instances. This is done to avoid having to concatenate\n * variables to strings to essentially namespace the field, for most cases.\n */\nexport class Singleflight {\n    private constructor() {\n    }\n\n    /**\n     * A void marker to help with returning a value in a singleflight context.\n     * If your code doesn't return anything, return this instead.\n     */\n    public static Void = Symbol(\"void\");\n\n    /**\n     * Acquire a singleflight context.\n     * @param {Object} instance An instance to associate the context with. Can be any object.\n     * @param {string} key A string key relevant to that instance to namespace under.\n     * @returns {SingleflightContext} Returns the context to execute the function.\n     */\n    public static for(instance: Object, key: string): SingleflightContext {\n        if (!instance || !key) throw new Error(\"An instance and key must be supplied\");\n        return new SingleflightContext(instance, key);\n    }\n\n    /**\n     * Forgets all results for a given instance.\n     * @param {Object} instance The instance to forget about.\n     */\n    public static forgetAllFor(instance: Object) {\n        keyMap.delete(instance);\n    }\n\n    /**\n     * Forgets all cached results for all instances. Intended for use by tests.\n     */\n    public static forgetAll() {\n        for (const k of keyMap.keys()) {\n            keyMap.remove(k);\n        }\n    }\n}\n\nclass SingleflightContext {\n    public constructor(private instance: Object, private key: string) {\n    }\n\n    /**\n     * Forget this particular instance and key combination, discarding the result.\n     */\n    public forget() {\n        const map = keyMap.get(this.instance);\n        if (!map) return;\n        map.remove(this.key);\n        if (!map.size) keyMap.remove(this.instance);\n    }\n\n    /**\n     * Execute a function. If a result is already known, that will be returned instead\n     * of executing the provided function. However, if no result is known then the function\n     * will be called, with its return value cached. The function must return a value\n     * other than `undefined` - take a look at Singleflight.Void if you don't have a return\n     * to make.\n     *\n     * Note that this technically allows the caller to provide a different function each time:\n     * this is largely considered a bad idea and should not be done. Singleflights work off the\n     * premise that something needs to happen once, so duplicate executions will be ignored.\n     *\n     * For ideal performance and behaviour, functions which return promises are preferred. If\n     * a function is not returning a promise, it should return as soon as possible to avoid a\n     * second call potentially racing it. The promise returned by this function will be that\n     * of the first execution of the function, even on duplicate calls.\n     * @param {Function} fn The function to execute.\n     * @returns The recorded value.\n     */\n    public do<T>(fn: () => T): T {\n        const map = keyMap.getOrCreate(this.instance, new EnhancedMap<string, unknown>());\n\n        // We have to manually getOrCreate() because we need to execute the fn\n        let val = <T>map.get(this.key);\n        if (val === undefined) {\n            val = fn();\n            map.set(this.key, val);\n        }\n\n        return val;\n    }\n}\n"],"mappings":";;;;;;;;;;;AAgBA;;AAhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA,MAAMA,MAAM,GAAG,IAAIC,iBAAJ,EAAf;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACO,MAAMC,YAAN,CAAmB;EACdC,WAAW,GAAG,CACrB;EAED;AACJ;AACA;AACA;;;EAGI;AACJ;AACA;AACA;AACA;AACA;EACqB,OAAHC,GAAG,CAACC,QAAD,EAAmBC,GAAnB,EAAqD;IAClE,IAAI,CAACD,QAAD,IAAa,CAACC,GAAlB,EAAuB,MAAM,IAAIC,KAAJ,CAAU,sCAAV,CAAN;IACvB,OAAO,IAAIC,mBAAJ,CAAwBH,QAAxB,EAAkCC,GAAlC,CAAP;EACH;EAED;AACJ;AACA;AACA;;;EAC8B,OAAZG,YAAY,CAACJ,QAAD,EAAmB;IACzCL,MAAM,CAACU,MAAP,CAAcL,QAAd;EACH;EAED;AACJ;AACA;;;EAC2B,OAATM,SAAS,GAAG;IACtB,KAAK,MAAMC,CAAX,IAAgBZ,MAAM,CAACa,IAAP,EAAhB,EAA+B;MAC3Bb,MAAM,CAACc,MAAP,CAAcF,CAAd;IACH;EACJ;;AApCqB;;;8BAAbV,Y,UAQYa,MAAM,CAAC,MAAD,C;;AA+B/B,MAAMP,mBAAN,CAA0B;EACfL,WAAW,CAASE,QAAT,EAAmCC,GAAnC,EAAgD;IAAA,KAAvCD,QAAuC,GAAvCA,QAAuC;IAAA,KAAbC,GAAa,GAAbA,GAAa;EACjE;EAED;AACJ;AACA;;;EACWU,MAAM,GAAG;IACZ,MAAMC,GAAG,GAAGjB,MAAM,CAACkB,GAAP,CAAW,KAAKb,QAAhB,CAAZ;IACA,IAAI,CAACY,GAAL,EAAU;IACVA,GAAG,CAACH,MAAJ,CAAW,KAAKR,GAAhB;IACA,IAAI,CAACW,GAAG,CAACE,IAAT,EAAenB,MAAM,CAACc,MAAP,CAAc,KAAKT,QAAnB;EAClB;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACWe,EAAE,CAAIC,EAAJ,EAAoB;IACzB,MAAMJ,GAAG,GAAGjB,MAAM,CAACsB,WAAP,CAAmB,KAAKjB,QAAxB,EAAkC,IAAIJ,iBAAJ,EAAlC,CAAZ,CADyB,CAGzB;;IACA,IAAIsB,GAAG,GAAMN,GAAG,CAACC,GAAJ,CAAQ,KAAKZ,GAAb,CAAb;;IACA,IAAIiB,GAAG,KAAKC,SAAZ,EAAuB;MACnBD,GAAG,GAAGF,EAAE,EAAR;MACAJ,GAAG,CAACQ,GAAJ,CAAQ,KAAKnB,GAAb,EAAkBiB,GAAlB;IACH;;IAED,OAAOA,GAAP;EACH;;AA3CqB"}