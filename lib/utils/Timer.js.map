{"version":3,"file":"Timer.js","names":["Timer","constructor","timeout","now","Date","elapsed","startTs","resolve","setNotStarted","delta","timerHandle","setTimeout","onTimeout","promise","Promise","reject","finally","changeTimeout","isSmallerTimeout","isRunning","clearTimeout","start","restart","abort","Error","finished"],"sources":["../../src/utils/Timer.ts"],"sourcesContent":["/*\nCopyright 2018, 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\nA countdown timer, exposing a promise api.\nA timer starts in a non-started state,\nand needs to be started by calling `start()`` on it first.\n\nTimers can be `abort()`-ed which makes the promise reject prematurely.\n\nOnce a timer is finished or aborted, it can't be started again\n(because the promise should not be replaced). Instead, create\na new one through `clone()` or `cloneIfRun()`.\n*/\nexport default class Timer {\n    private timerHandle: number;\n    private startTs: number;\n    private promise: Promise<void>;\n    private resolve: () => void;\n    private reject: (Error) => void;\n\n    constructor(private timeout: number) {\n        this.setNotStarted();\n    }\n\n    private setNotStarted() {\n        this.timerHandle = null;\n        this.startTs = null;\n        this.promise = new Promise<void>((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        }).finally(() => {\n            this.timerHandle = null;\n        });\n    }\n\n    private onTimeout = () => {\n        const now = Date.now();\n        const elapsed = now - this.startTs;\n        if (elapsed >= this.timeout) {\n            this.resolve();\n            this.setNotStarted();\n        } else {\n            const delta = this.timeout - elapsed;\n            this.timerHandle = setTimeout(this.onTimeout, delta);\n        }\n    };\n\n    changeTimeout(timeout: number) {\n        if (timeout === this.timeout) {\n            return;\n        }\n        const isSmallerTimeout = timeout < this.timeout;\n        this.timeout = timeout;\n        if (this.isRunning() && isSmallerTimeout) {\n            clearTimeout(this.timerHandle);\n            this.onTimeout();\n        }\n    }\n\n    /**\n     * if not started before, starts the timer.\n     * @returns {Timer} the same timer\n     */\n    start() {\n        if (!this.isRunning()) {\n            this.startTs = Date.now();\n            this.timerHandle = setTimeout(this.onTimeout, this.timeout);\n        }\n        return this;\n    }\n\n    /**\n     * (re)start the timer. If it's running, reset the timeout. If not, start it.\n     * @returns {Timer} the same timer\n     */\n    restart() {\n        if (this.isRunning()) {\n            // don't clearTimeout here as this method\n            // can be called in fast succession,\n            // instead just take note and compare\n            // when the already running timeout expires\n            this.startTs = Date.now();\n            return this;\n        } else {\n            return this.start();\n        }\n    }\n\n    /**\n     * if the timer is running, abort it,\n     * and reject the promise for this timer.\n     * @returns {Timer} the same timer\n     */\n    abort() {\n        if (this.isRunning()) {\n            clearTimeout(this.timerHandle);\n            this.reject(new Error(\"Timer was aborted.\"));\n            this.setNotStarted();\n        }\n        return this;\n    }\n\n    /**\n     *promise that will resolve when the timer elapses,\n     *or is rejected when abort is called\n     *@return {Promise}\n     */\n    finished() {\n        return this.promise;\n    }\n\n    isRunning() {\n        return this.timerHandle !== null;\n    }\n}\n"],"mappings":";;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,MAAMA,KAAN,CAAY;EAOvBC,WAAW,CAASC,OAAT,EAA0B;IAAA,KAAjBA,OAAiB,GAAjBA,OAAiB;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA,iDAejB,MAAM;MACtB,MAAMC,GAAG,GAAGC,IAAI,CAACD,GAAL,EAAZ;MACA,MAAME,OAAO,GAAGF,GAAG,GAAG,KAAKG,OAA3B;;MACA,IAAID,OAAO,IAAI,KAAKH,OAApB,EAA6B;QACzB,KAAKK,OAAL;QACA,KAAKC,aAAL;MACH,CAHD,MAGO;QACH,MAAMC,KAAK,GAAG,KAAKP,OAAL,GAAeG,OAA7B;QACA,KAAKK,WAAL,GAAmBC,UAAU,CAAC,KAAKC,SAAN,EAAiBH,KAAjB,CAA7B;MACH;IACJ,CAzBoC;IACjC,KAAKD,aAAL;EACH;;EAEOA,aAAa,GAAG;IACpB,KAAKE,WAAL,GAAmB,IAAnB;IACA,KAAKJ,OAAL,GAAe,IAAf;IACA,KAAKO,OAAL,GAAe,IAAIC,OAAJ,CAAkB,CAACP,OAAD,EAAUQ,MAAV,KAAqB;MAClD,KAAKR,OAAL,GAAeA,OAAf;MACA,KAAKQ,MAAL,GAAcA,MAAd;IACH,CAHc,EAGZC,OAHY,CAGJ,MAAM;MACb,KAAKN,WAAL,GAAmB,IAAnB;IACH,CALc,CAAf;EAMH;;EAcDO,aAAa,CAACf,OAAD,EAAkB;IAC3B,IAAIA,OAAO,KAAK,KAAKA,OAArB,EAA8B;MAC1B;IACH;;IACD,MAAMgB,gBAAgB,GAAGhB,OAAO,GAAG,KAAKA,OAAxC;IACA,KAAKA,OAAL,GAAeA,OAAf;;IACA,IAAI,KAAKiB,SAAL,MAAoBD,gBAAxB,EAA0C;MACtCE,YAAY,CAAC,KAAKV,WAAN,CAAZ;MACA,KAAKE,SAAL;IACH;EACJ;EAED;AACJ;AACA;AACA;;;EACIS,KAAK,GAAG;IACJ,IAAI,CAAC,KAAKF,SAAL,EAAL,EAAuB;MACnB,KAAKb,OAAL,GAAeF,IAAI,CAACD,GAAL,EAAf;MACA,KAAKO,WAAL,GAAmBC,UAAU,CAAC,KAAKC,SAAN,EAAiB,KAAKV,OAAtB,CAA7B;IACH;;IACD,OAAO,IAAP;EACH;EAED;AACJ;AACA;AACA;;;EACIoB,OAAO,GAAG;IACN,IAAI,KAAKH,SAAL,EAAJ,EAAsB;MAClB;MACA;MACA;MACA;MACA,KAAKb,OAAL,GAAeF,IAAI,CAACD,GAAL,EAAf;MACA,OAAO,IAAP;IACH,CAPD,MAOO;MACH,OAAO,KAAKkB,KAAL,EAAP;IACH;EACJ;EAED;AACJ;AACA;AACA;AACA;;;EACIE,KAAK,GAAG;IACJ,IAAI,KAAKJ,SAAL,EAAJ,EAAsB;MAClBC,YAAY,CAAC,KAAKV,WAAN,CAAZ;MACA,KAAKK,MAAL,CAAY,IAAIS,KAAJ,CAAU,oBAAV,CAAZ;MACA,KAAKhB,aAAL;IACH;;IACD,OAAO,IAAP;EACH;EAED;AACJ;AACA;AACA;AACA;;;EACIiB,QAAQ,GAAG;IACP,OAAO,KAAKZ,OAAZ;EACH;;EAEDM,SAAS,GAAG;IACR,OAAO,KAAKT,WAAL,KAAqB,IAA5B;EACH;;AApGsB"}