{"version":3,"file":"QueryMatcher.js","names":["QueryMatcher","constructor","objects","options","keys","_options","setObjects","shouldMatchWordsOnly","undefined","_items","Map","object","keyValues","at","funcs","f","v","Array","isArray","push","index","keyValue","Object","entries","key","processQuery","has","set","get","keyWeight","Number","match","query","limit","replace","length","matches","candidates","resultKey","indexOf","map","candidate","sort","a","b","dedupped","uniq","maxLength","slice","fuzzy","removeHiddenChars","toLowerCase"],"sources":["../../src/autocomplete/QueryMatcher.ts"],"sourcesContent":["/*\nCopyright 2017 Aviral Dasgupta\nCopyright 2018 Michael Telatynski <7t3chguy@gmail.com>\nCopyright 2018 New Vector Ltd\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { at, uniq } from 'lodash';\nimport { removeHiddenChars } from \"matrix-js-sdk/src/utils\";\n\nimport { TimelineRenderingType } from '../contexts/RoomContext';\nimport { Leaves } from \"../@types/common\";\n\ninterface IOptions<T extends {}> {\n    keys: Array<Leaves<T>>;\n    funcs?: Array<(o: T) => string | string[]>;\n    shouldMatchWordsOnly?: boolean;\n    // whether to apply unhomoglyph and strip diacritics to fuzz up the search. Defaults to true\n    fuzzy?: boolean;\n    context?: TimelineRenderingType;\n}\n\n/**\n * Simple search matcher that matches any results with the query string anywhere\n * in the search string. Returns matches in the order the query string appears\n * in the search key, earliest first, then in the order the search key appears\n * in the provided array of keys, then in the order the items appeared in the\n * source array.\n *\n * @param {Object[]} objects Initial list of objects. Equivalent to calling\n *     setObjects() after construction\n * @param {Object} options Options object\n * @param {string[]} options.keys List of keys to use as indexes on the objects\n * @param {function[]} options.funcs List of functions that when called with the\n *     object as an arg will return a string to use as an index\n */\nexport default class QueryMatcher<T extends Object> {\n    private _options: IOptions<T>;\n    private _items: Map<string, {object: T, keyWeight: number}[]>;\n\n    constructor(objects: T[], options: IOptions<T> = { keys: [] }) {\n        this._options = options;\n\n        this.setObjects(objects);\n\n        // By default, we remove any non-alphanumeric characters ([^A-Za-z0-9_]) from the\n        // query and the value being queried before matching\n        if (this._options.shouldMatchWordsOnly === undefined) {\n            this._options.shouldMatchWordsOnly = true;\n        }\n    }\n\n    setObjects(objects: T[]) {\n        this._items = new Map();\n\n        for (const object of objects) {\n            // Need to use unsafe coerce here because the objects can have any\n            // type for their values. We assume that those values who's keys have\n            // been specified will be string. Also, we cannot infer all the\n            // types of the keys of the objects at compile.\n            const keyValues = at<string>(<any>object, this._options.keys);\n\n            if (this._options.funcs) {\n                for (const f of this._options.funcs) {\n                    const v = f(object);\n                    if (Array.isArray(v)) {\n                        keyValues.push(...v);\n                    } else {\n                        keyValues.push(v);\n                    }\n                }\n            }\n\n            for (const [index, keyValue] of Object.entries(keyValues)) {\n                if (!keyValue) continue; // skip falsy keyValues\n                const key = this.processQuery(keyValue);\n                if (!this._items.has(key)) {\n                    this._items.set(key, []);\n                }\n                this._items.get(key).push({\n                    keyWeight: Number(index),\n                    object,\n                });\n            }\n        }\n    }\n\n    match(query: string, limit = -1): T[] {\n        query = this.processQuery(query);\n        if (this._options.shouldMatchWordsOnly) {\n            query = query.replace(/[^\\w]/g, '');\n        }\n        if (query.length === 0) {\n            return [];\n        }\n        const matches = [];\n        // Iterate through the map & check each key.\n        // ES6 Map iteration order is defined to be insertion order, so results\n        // here will come out in the order they were put in.\n        for (const [key, candidates] of this._items.entries()) {\n            let resultKey = key;\n            if (this._options.shouldMatchWordsOnly) {\n                resultKey = resultKey.replace(/[^\\w]/g, '');\n            }\n            const index = resultKey.indexOf(query);\n            if (index !== -1) {\n                matches.push(\n                    ...candidates.map((candidate) => ({ index, ...candidate })),\n                );\n            }\n        }\n\n        // Sort matches by where the query appeared in the search key, then by\n        // where the matched key appeared in the provided array of keys.\n        matches.sort((a, b) => {\n            if (a.index < b.index) {\n                return -1;\n            } else if (a.index === b.index) {\n                if (a.keyWeight < b.keyWeight) {\n                    return -1;\n                } else if (a.keyWeight === b.keyWeight) {\n                    return 0;\n                }\n            }\n\n            return 1;\n        });\n\n        // Now map the keys to the result objects. Also remove any duplicates.\n        const dedupped = uniq(matches.map((match) => match.object));\n        const maxLength = limit === -1 ? dedupped.length : limit;\n\n        return dedupped.slice(0, maxLength);\n    }\n\n    private processQuery(query: string): string {\n        if (this._options.fuzzy !== false) {\n            // lower case both the input and the output for consistency\n            return removeHiddenChars(query.toLowerCase()).toLowerCase();\n        }\n        return query.toLowerCase();\n    }\n}\n"],"mappings":"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"}