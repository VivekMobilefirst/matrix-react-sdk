{"version":3,"file":"AsyncStore.js","names":["UPDATE_EVENT","AsyncStore","EventEmitter","constructor","dispatcher","initialState","AwaitLock","dispatcherRef","register","onDispatch","bind","storeState","state","stop","unregister","updateState","newState","lock","acquireAsync","Object","freeze","assign","emit","release","reset","quiet"],"sources":["../../src/stores/AsyncStore.ts"],"sourcesContent":["/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { EventEmitter } from 'events';\nimport AwaitLock from 'await-lock';\nimport { Dispatcher } from \"flux\";\n\nimport { ActionPayload } from \"../dispatcher/payloads\";\n\n/**\n * The event/channel to listen for in an AsyncStore.\n */\nexport const UPDATE_EVENT = \"update\";\n\n/**\n * Represents a minimal store which works similar to Flux stores. Instead\n * of everything needing to happen in a dispatch cycle, everything can\n * happen async to that cycle.\n *\n * The store operates by using Object.assign() to mutate state - it sends the\n * state objects (current and new) through the function onto a new empty\n * object. Because of this, it is recommended to break out your state to be as\n * safe as possible. The state mutations are also locked, preventing concurrent\n * writes.\n *\n * All updates to the store happen on the UPDATE_EVENT event channel with the\n * one argument being the instance of the store.\n *\n * To update the state, use updateState() and preferably await the result to\n * help prevent lock conflicts.\n */\nexport abstract class AsyncStore<T extends Object> extends EventEmitter {\n    private storeState: Readonly<T>;\n    private lock = new AwaitLock();\n    private readonly dispatcherRef: string;\n\n    /**\n     * Creates a new AsyncStore using the given dispatcher.\n     * @param {Dispatcher<ActionPayload>} dispatcher The dispatcher to rely upon.\n     * @param {T} initialState The initial state for the store.\n     */\n    protected constructor(private dispatcher: Dispatcher<ActionPayload>, initialState: T = <T>{}) {\n        super();\n\n        this.dispatcherRef = dispatcher.register(this.onDispatch.bind(this));\n        this.storeState = initialState;\n    }\n\n    /**\n     * The current state of the store. Cannot be mutated.\n     */\n    protected get state(): T {\n        return this.storeState;\n    }\n\n    /**\n     * Stops the store's listening functions, such as the listener to the dispatcher.\n     */\n    protected stop() {\n        if (this.dispatcherRef) this.dispatcher.unregister(this.dispatcherRef);\n    }\n\n    /**\n     * Updates the state of the store.\n     * @param {T|*} newState The state to update in the store using Object.assign()\n     */\n    protected async updateState(newState: T | Object) {\n        await this.lock.acquireAsync();\n        try {\n            this.storeState = Object.freeze(Object.assign(<T>{}, this.storeState, newState));\n            this.emit(UPDATE_EVENT, this);\n        } finally {\n            await this.lock.release();\n        }\n    }\n\n    /**\n     * Resets the store's to the provided state or an empty object.\n     * @param {T|*} newState The new state of the store.\n     * @param {boolean} quiet If true, the function will not raise an UPDATE_EVENT.\n     */\n    protected async reset(newState: T | Object = null, quiet = false) {\n        await this.lock.acquireAsync();\n        try {\n            this.storeState = Object.freeze(<T>(newState || {}));\n            if (!quiet) this.emit(UPDATE_EVENT, this);\n        } finally {\n            await this.lock.release();\n        }\n    }\n\n    /**\n     * Called when the dispatcher broadcasts a dispatch event.\n     * @param {ActionPayload} payload The event being dispatched.\n     */\n    protected abstract onDispatch(payload: ActionPayload);\n}\n"],"mappings":";;;;;;;;;;;AAgBA;;AACA;;AAjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAQA;AACA;AACA;AACO,MAAMA,YAAY,GAAG,QAArB;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AACO,MAAeC,UAAf,SAAoDC,oBAApD,CAAiE;EAKpE;AACJ;AACA;AACA;AACA;EACcC,WAAW,CAASC,UAAT,EAAyE;IAAA,IAAzBC,YAAyB,uEAAJ,EAAI;IAC1F;IAD0F,KAAhED,UAAgE,GAAhEA,UAAgE;IAAA;IAAA,4CAR/E,IAAIE,kBAAJ,EAQ+E;IAAA;IAG1F,KAAKC,aAAL,GAAqBH,UAAU,CAACI,QAAX,CAAoB,KAAKC,UAAL,CAAgBC,IAAhB,CAAqB,IAArB,CAApB,CAArB;IACA,KAAKC,UAAL,GAAkBN,YAAlB;EACH;EAED;AACJ;AACA;;;EACuB,IAALO,KAAK,GAAM;IACrB,OAAO,KAAKD,UAAZ;EACH;EAED;AACJ;AACA;;;EACcE,IAAI,GAAG;IACb,IAAI,KAAKN,aAAT,EAAwB,KAAKH,UAAL,CAAgBU,UAAhB,CAA2B,KAAKP,aAAhC;EAC3B;EAED;AACJ;AACA;AACA;;;EAC+B,MAAXQ,WAAW,CAACC,QAAD,EAAuB;IAC9C,MAAM,KAAKC,IAAL,CAAUC,YAAV,EAAN;;IACA,IAAI;MACA,KAAKP,UAAL,GAAkBQ,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACE,MAAP,CAAiB,EAAjB,EAAqB,KAAKV,UAA1B,EAAsCK,QAAtC,CAAd,CAAlB;MACA,KAAKM,IAAL,CAAUtB,YAAV,EAAwB,IAAxB;IACH,CAHD,SAGU;MACN,MAAM,KAAKiB,IAAL,CAAUM,OAAV,EAAN;IACH;EACJ;EAED;AACJ;AACA;AACA;AACA;;;EACyB,MAALC,KAAK,GAA6C;IAAA,IAA5CR,QAA4C,uEAArB,IAAqB;IAAA,IAAfS,KAAe,uEAAP,KAAO;IAC9D,MAAM,KAAKR,IAAL,CAAUC,YAAV,EAAN;;IACA,IAAI;MACA,KAAKP,UAAL,GAAkBQ,MAAM,CAACC,MAAP,CAAkBJ,QAAQ,IAAI,EAA9B,CAAlB;MACA,IAAI,CAACS,KAAL,EAAY,KAAKH,IAAL,CAAUtB,YAAV,EAAwB,IAAxB;IACf,CAHD,SAGU;MACN,MAAM,KAAKiB,IAAL,CAAUM,OAAV,EAAN;IACH;EACJ;EAED;AACJ;AACA;AACA;;;AA/DwE"}