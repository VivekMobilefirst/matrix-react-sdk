{"version":3,"file":"RoomListStore.js","names":["LISTS_UPDATE_EVENT","RoomListStoreEvent","ListsUpdate","RoomListStoreClass","AsyncStoreWithClient","constructor","defaultDispatcher","Algorithm","MarkedExecution","tagId","Object","keys","orderedLists","RoomNotificationStateStore","instance","getListState","setRooms","emit","forceUpdate","updateFn","mark","trigger","recalculatePrefiltering","setMaxListeners","algorithm","start","setupWatchers","SpaceWatcher","getOrderedRooms","resetStore","reset","prefilterConditions","initialListsGenerated","off","LIST_UPDATED_EVENT","onAlgorithmListUpdated","FILTER_CHANGED","stop","on","makeReady","forcedClient","readyStore","useUnitTestClient","RoomViewStore","addListener","handleRVSUpdate","onAlgorithmFilterUpdated","logger","log","updateAlgorithmInstances","regenerateAllLists","matrixClient","activeRoomId","getRoomId","stickyRoom","setStickyRoom","activeRoom","getRoom","warn","onReady","onNotReady","onAction","payload","logicallyReady","TEST_MODE","onDispatchAsync","setImmediate","Error","action","readReceiptChangeIsFor","event","room","roomId","handleRoomUpdate","RoomUpdateCause","ReadReceipt","roomPayload","PossibleTagChange","eventPayload","isLiveEvent","isLiveUnfilteredRoomTimelineEvent","tryUpdate","updatedRoom","getType","EventType","RoomTombstone","getStateKey","newRoom","getContent","Timeline","getId","setTimeout","event_type","Direct","dmMap","userId","roomIds","membershipPayload","oldMembership","getEffectiveMembership","newMembership","membership","EffectiveMembership","Join","createEvent","currentState","getStateEvents","RoomCreate","prevRoom","isSticky","RoomRemoved","NewRoom","Invite","cause","getMyMembership","VisibilityProvider","onNewInvitedRoom","isRoomVisible","every","c","isVisible","shouldUpdate","hasTagSortingMap","updatesInhibited","rooms","getPlausibleRooms","currentSticky","stickyIsStillPresent","includes","setKnownRooms","setTagSorting","sort","setAndPersistTagSorting","localStorage","setItem","getTagSorting","getStoredTagSorting","getItem","calculateTagSorting","isDefaultRecent","DefaultTagID","DM","defaultSort","SortAlgorithm","Recent","Alphabetic","settingAlphabetical","SettingsStore","getValue","definedSort","storedSort","tagSort","isNullOrUndefined","setListOrder","order","setAndPersistListOrder","setListOrdering","getListOrder","getListOrdering","getStoredListOrder","calculateListOrder","defaultOrder","ListAlgorithm","Natural","settingImportance","definedOrder","storedOrder","listOrder","Importance","tag","getVisibleRooms","filter","r","length","sorts","orders","allTags","OrderedDefaultTagIDs","RoomListLayoutStore","ensureLayoutExists","populateTags","addFilter","promise","Promise","resolve","onPrefilterUpdated","push","then","removeFilter","removed","idx","indexOf","splice","getTagsForRoom","algorithmTags","Untagged","manualRoomUpdate","RoomListStore","internalInstance","window","mxRoomListStore"],"sources":["../../../src/stores/room-list/RoomListStore.ts"],"sourcesContent":["/*\nCopyright 2018 - 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { MatrixClient } from \"matrix-js-sdk/src/client\";\nimport { Room } from \"matrix-js-sdk/src/models/room\";\nimport { isNullOrUndefined } from \"matrix-js-sdk/src/utils\";\nimport { logger } from \"matrix-js-sdk/src/logger\";\nimport { EventType } from \"matrix-js-sdk/src/@types/event\";\n\nimport SettingsStore from \"../../settings/SettingsStore\";\nimport { DefaultTagID, OrderedDefaultTagIDs, RoomUpdateCause, TagID } from \"./models\";\nimport { IListOrderingMap, ITagMap, ITagSortingMap, ListAlgorithm, SortAlgorithm } from \"./algorithms/models\";\nimport { ActionPayload } from \"../../dispatcher/payloads\";\nimport defaultDispatcher from \"../../dispatcher/dispatcher\";\nimport { readReceiptChangeIsFor } from \"../../utils/read-receipts\";\nimport { FILTER_CHANGED, IFilterCondition } from \"./filters/IFilterCondition\";\nimport { RoomViewStore } from \"../RoomViewStore\";\nimport { Algorithm, LIST_UPDATED_EVENT } from \"./algorithms/Algorithm\";\nimport { EffectiveMembership, getEffectiveMembership } from \"../../utils/membership\";\nimport RoomListLayoutStore from \"./RoomListLayoutStore\";\nimport { MarkedExecution } from \"../../utils/MarkedExecution\";\nimport { AsyncStoreWithClient } from \"../AsyncStoreWithClient\";\nimport { RoomNotificationStateStore } from \"../notifications/RoomNotificationStateStore\";\nimport { VisibilityProvider } from \"./filters/VisibilityProvider\";\nimport { SpaceWatcher } from \"./SpaceWatcher\";\nimport { IRoomTimelineActionPayload } from \"../../actions/MatrixActionCreators\";\nimport { RoomListStore as Interface, RoomListStoreEvent } from \"./Interface\";\n\ninterface IState {\n    // state is tracked in underlying classes\n}\n\nexport const LISTS_UPDATE_EVENT = RoomListStoreEvent.ListsUpdate;\n\nexport class RoomListStoreClass extends AsyncStoreWithClient<IState> implements Interface {\n    /**\n     * Set to true if you're running tests on the store. Should not be touched in\n     * any other environment.\n     */\n    public static TEST_MODE = false;\n\n    private initialListsGenerated = false;\n    private algorithm = new Algorithm();\n    private prefilterConditions: IFilterCondition[] = [];\n    private updateFn = new MarkedExecution(() => {\n        for (const tagId of Object.keys(this.orderedLists)) {\n            RoomNotificationStateStore.instance.getListState(tagId).setRooms(this.orderedLists[tagId]);\n        }\n        this.emit(LISTS_UPDATE_EVENT);\n    });\n\n    constructor() {\n        super(defaultDispatcher);\n        this.setMaxListeners(20); // RoomList + LeftPanel + 8xRoomSubList + spares\n        this.algorithm.start();\n    }\n\n    private setupWatchers() {\n        // TODO: Maybe destroy this if this class supports destruction\n        new SpaceWatcher(this);\n    }\n\n    public get orderedLists(): ITagMap {\n        if (!this.algorithm) return {}; // No tags yet.\n        return this.algorithm.getOrderedRooms();\n    }\n\n    // Intended for test usage\n    public async resetStore() {\n        await this.reset();\n        this.prefilterConditions = [];\n        this.initialListsGenerated = false;\n\n        this.algorithm.off(LIST_UPDATED_EVENT, this.onAlgorithmListUpdated);\n        this.algorithm.off(FILTER_CHANGED, this.onAlgorithmListUpdated);\n        this.algorithm.stop();\n        this.algorithm = new Algorithm();\n        this.algorithm.on(LIST_UPDATED_EVENT, this.onAlgorithmListUpdated);\n        this.algorithm.on(FILTER_CHANGED, this.onAlgorithmListUpdated);\n\n        // Reset state without causing updates as the client will have been destroyed\n        // and downstream code will throw NPE errors.\n        await this.reset(null, true);\n    }\n\n    // Public for test usage. Do not call this.\n    public async makeReady(forcedClient?: MatrixClient) {\n        if (forcedClient) {\n            this.readyStore.useUnitTestClient(forcedClient);\n        }\n\n        RoomViewStore.instance.addListener(() => this.handleRVSUpdate({}));\n        this.algorithm.on(LIST_UPDATED_EVENT, this.onAlgorithmListUpdated);\n        this.algorithm.on(FILTER_CHANGED, this.onAlgorithmFilterUpdated);\n        this.setupWatchers();\n\n        // Update any settings here, as some may have happened before we were logically ready.\n        logger.log(\"Regenerating room lists: Startup\");\n        this.updateAlgorithmInstances();\n        this.regenerateAllLists({ trigger: false });\n        this.handleRVSUpdate({ trigger: false }); // fake an RVS update to adjust sticky room, if needed\n\n        this.updateFn.mark(); // we almost certainly want to trigger an update.\n        this.updateFn.trigger();\n    }\n\n    /**\n     * Handles suspected RoomViewStore changes.\n     * @param trigger Set to false to prevent a list update from being sent. Should only\n     * be used if the calling code will manually trigger the update.\n     */\n    private handleRVSUpdate({ trigger = true }) {\n        if (!this.matrixClient) return; // We assume there won't be RVS updates without a client\n\n        const activeRoomId = RoomViewStore.instance.getRoomId();\n        if (!activeRoomId && this.algorithm.stickyRoom) {\n            this.algorithm.setStickyRoom(null);\n        } else if (activeRoomId) {\n            const activeRoom = this.matrixClient.getRoom(activeRoomId);\n            if (!activeRoom) {\n                logger.warn(`${activeRoomId} is current in RVS but missing from client - clearing sticky room`);\n                this.algorithm.setStickyRoom(null);\n            } else if (activeRoom !== this.algorithm.stickyRoom) {\n                this.algorithm.setStickyRoom(activeRoom);\n            }\n        }\n\n        if (trigger) this.updateFn.trigger();\n    }\n\n    protected async onReady(): Promise<any> {\n        await this.makeReady();\n    }\n\n    protected async onNotReady(): Promise<any> {\n        await this.resetStore();\n    }\n\n    protected async onAction(payload: ActionPayload) {\n        // If we're not remotely ready, don't even bother scheduling the dispatch handling.\n        // This is repeated in the handler just in case things change between a decision here and\n        // when the timer fires.\n        const logicallyReady = this.matrixClient && this.initialListsGenerated;\n        if (!logicallyReady) return;\n\n        // When we're running tests we can't reliably use setImmediate out of timing concerns.\n        // As such, we use a more synchronous model.\n        if (RoomListStoreClass.TEST_MODE) {\n            await this.onDispatchAsync(payload);\n            return;\n        }\n\n        // We do this to intentionally break out of the current event loop task, allowing\n        // us to instead wait for a more convenient time to run our updates.\n        setImmediate(() => this.onDispatchAsync(payload));\n    }\n\n    protected async onDispatchAsync(payload: ActionPayload) {\n        // Everything here requires a MatrixClient or some sort of logical readiness.\n        const logicallyReady = this.matrixClient && this.initialListsGenerated;\n        if (!logicallyReady) return;\n\n        if (!this.algorithm) {\n            // This shouldn't happen because `initialListsGenerated` implies we have an algorithm.\n            throw new Error(\"Room list store has no algorithm to process dispatcher update with\");\n        }\n\n        if (payload.action === 'MatrixActions.Room.receipt') {\n            // First see if the receipt event is for our own user. If it was, trigger\n            // a room update (we probably read the room on a different device).\n            if (readReceiptChangeIsFor(payload.event, this.matrixClient)) {\n                const room = payload.room;\n                if (!room) {\n                    logger.warn(`Own read receipt was in unknown room ${room.roomId}`);\n                    return;\n                }\n                await this.handleRoomUpdate(room, RoomUpdateCause.ReadReceipt);\n                this.updateFn.trigger();\n                return;\n            }\n        } else if (payload.action === 'MatrixActions.Room.tags') {\n            const roomPayload = (<any>payload); // TODO: Type out the dispatcher types\n            await this.handleRoomUpdate(roomPayload.room, RoomUpdateCause.PossibleTagChange);\n            this.updateFn.trigger();\n        } else if (payload.action === 'MatrixActions.Room.timeline') {\n            const eventPayload = <IRoomTimelineActionPayload>payload;\n\n            // Ignore non-live events (backfill) and notification timeline set events (without a room)\n            if (!eventPayload.isLiveEvent ||\n                !eventPayload.isLiveUnfilteredRoomTimelineEvent ||\n                !eventPayload.room\n            ) {\n                return;\n            }\n\n            const roomId = eventPayload.event.getRoomId();\n            const room = this.matrixClient.getRoom(roomId);\n            const tryUpdate = async (updatedRoom: Room) => {\n                if (eventPayload.event.getType() === EventType.RoomTombstone &&\n                    eventPayload.event.getStateKey() === ''\n                ) {\n                    const newRoom = this.matrixClient.getRoom(eventPayload.event.getContent()['replacement_room']);\n                    if (newRoom) {\n                        // If we have the new room, then the new room check will have seen the predecessor\n                        // and did the required updates, so do nothing here.\n                        return;\n                    }\n                }\n                await this.handleRoomUpdate(updatedRoom, RoomUpdateCause.Timeline);\n                this.updateFn.trigger();\n            };\n            if (!room) {\n                logger.warn(`Live timeline event ${eventPayload.event.getId()} received without associated room`);\n                logger.warn(`Queuing failed room update for retry as a result.`);\n                setTimeout(async () => {\n                    const updatedRoom = this.matrixClient.getRoom(roomId);\n                    await tryUpdate(updatedRoom);\n                }, 100); // 100ms should be enough for the room to show up\n                return;\n            } else {\n                await tryUpdate(room);\n            }\n        } else if (payload.action === 'MatrixActions.Event.decrypted') {\n            const eventPayload = (<any>payload); // TODO: Type out the dispatcher types\n            const roomId = eventPayload.event.getRoomId();\n            if (!roomId) {\n                return;\n            }\n            const room = this.matrixClient.getRoom(roomId);\n            if (!room) {\n                logger.warn(`Event ${eventPayload.event.getId()} was decrypted in an unknown room ${roomId}`);\n                return;\n            }\n            await this.handleRoomUpdate(room, RoomUpdateCause.Timeline);\n            this.updateFn.trigger();\n        } else if (payload.action === 'MatrixActions.accountData' && payload.event_type === EventType.Direct) {\n            const eventPayload = (<any>payload); // TODO: Type out the dispatcher types\n            const dmMap = eventPayload.event.getContent();\n            for (const userId of Object.keys(dmMap)) {\n                const roomIds = dmMap[userId];\n                for (const roomId of roomIds) {\n                    const room = this.matrixClient.getRoom(roomId);\n                    if (!room) {\n                        logger.warn(`${roomId} was found in DMs but the room is not in the store`);\n                        continue;\n                    }\n\n                    // We expect this RoomUpdateCause to no-op if there's no change, and we don't expect\n                    // the user to have hundreds of rooms to update in one event. As such, we just hammer\n                    // away at updates until the problem is solved. If we were expecting more than a couple\n                    // of rooms to be updated at once, we would consider batching the rooms up.\n                    await this.handleRoomUpdate(room, RoomUpdateCause.PossibleTagChange);\n                }\n            }\n            this.updateFn.trigger();\n        } else if (payload.action === 'MatrixActions.Room.myMembership') {\n            const membershipPayload = (<any>payload); // TODO: Type out the dispatcher types\n            const oldMembership = getEffectiveMembership(membershipPayload.oldMembership);\n            const newMembership = getEffectiveMembership(membershipPayload.membership);\n            if (oldMembership !== EffectiveMembership.Join && newMembership === EffectiveMembership.Join) {\n                // If we're joining an upgraded room, we'll want to make sure we don't proliferate\n                // the dead room in the list.\n                const createEvent = membershipPayload.room.currentState.getStateEvents(EventType.RoomCreate, \"\");\n                if (createEvent && createEvent.getContent()['predecessor']) {\n                    const prevRoom = this.matrixClient.getRoom(createEvent.getContent()['predecessor']['room_id']);\n                    if (prevRoom) {\n                        const isSticky = this.algorithm.stickyRoom === prevRoom;\n                        if (isSticky) {\n                            this.algorithm.setStickyRoom(null);\n                        }\n\n                        // Note: we hit the algorithm instead of our handleRoomUpdate() function to\n                        // avoid redundant updates.\n                        this.algorithm.handleRoomUpdate(prevRoom, RoomUpdateCause.RoomRemoved);\n                    }\n                }\n\n                await this.handleRoomUpdate(membershipPayload.room, RoomUpdateCause.NewRoom);\n                this.updateFn.trigger();\n                return;\n            }\n\n            if (oldMembership !== EffectiveMembership.Invite && newMembership === EffectiveMembership.Invite) {\n                await this.handleRoomUpdate(membershipPayload.room, RoomUpdateCause.NewRoom);\n                this.updateFn.trigger();\n                return;\n            }\n\n            // If it's not a join, it's transitioning into a different list (possibly historical)\n            if (oldMembership !== newMembership) {\n                await this.handleRoomUpdate(membershipPayload.room, RoomUpdateCause.PossibleTagChange);\n                this.updateFn.trigger();\n                return;\n            }\n        }\n    }\n\n    private async handleRoomUpdate(room: Room, cause: RoomUpdateCause): Promise<any> {\n        if (cause === RoomUpdateCause.NewRoom && room.getMyMembership() === \"invite\") {\n            // Let the visibility provider know that there is a new invited room. It would be nice\n            // if this could just be an event that things listen for but the point of this is that\n            // we delay doing anything about this room until the VoipUserMapper had had a chance\n            // to do the things it needs to do to decide if we should show this room or not, so\n            // an even wouldn't et us do that.\n            await VisibilityProvider.instance.onNewInvitedRoom(room);\n        }\n\n        if (!VisibilityProvider.instance.isRoomVisible(room)) {\n            return; // don't do anything on rooms that aren't visible\n        }\n\n        if ((cause === RoomUpdateCause.NewRoom || cause === RoomUpdateCause.PossibleTagChange) &&\n            !this.prefilterConditions.every(c => c.isVisible(room))\n        ) {\n            return; // don't do anything on new/moved rooms which ought not to be shown\n        }\n\n        const shouldUpdate = this.algorithm.handleRoomUpdate(room, cause);\n        if (shouldUpdate) {\n            this.updateFn.mark();\n        }\n    }\n\n    private async recalculatePrefiltering() {\n        if (!this.algorithm) return;\n        if (!this.algorithm.hasTagSortingMap) return; // we're still loading\n\n        // Inhibit updates because we're about to lie heavily to the algorithm\n        this.algorithm.updatesInhibited = true;\n\n        // Figure out which rooms are about to be valid, and the state of affairs\n        const rooms = this.getPlausibleRooms();\n        const currentSticky = this.algorithm.stickyRoom;\n        const stickyIsStillPresent = currentSticky && rooms.includes(currentSticky);\n\n        // Reset the sticky room before resetting the known rooms so the algorithm\n        // doesn't freak out.\n        this.algorithm.setStickyRoom(null);\n        this.algorithm.setKnownRooms(rooms);\n\n        // Set the sticky room back, if needed, now that we have updated the store.\n        // This will use relative stickyness to the new room set.\n        if (stickyIsStillPresent) {\n            this.algorithm.setStickyRoom(currentSticky);\n        }\n\n        // Finally, mark an update and resume updates from the algorithm\n        this.updateFn.mark();\n        this.algorithm.updatesInhibited = false;\n    }\n\n    public setTagSorting(tagId: TagID, sort: SortAlgorithm) {\n        this.setAndPersistTagSorting(tagId, sort);\n        this.updateFn.trigger();\n    }\n\n    private setAndPersistTagSorting(tagId: TagID, sort: SortAlgorithm) {\n        this.algorithm.setTagSorting(tagId, sort);\n        // TODO: Per-account? https://github.com/vector-im/element-web/issues/14114\n        localStorage.setItem(`mx_tagSort_${tagId}`, sort);\n    }\n\n    public getTagSorting(tagId: TagID): SortAlgorithm {\n        return this.algorithm.getTagSorting(tagId);\n    }\n\n    // noinspection JSMethodCanBeStatic\n    private getStoredTagSorting(tagId: TagID): SortAlgorithm {\n        // TODO: Per-account? https://github.com/vector-im/element-web/issues/14114\n        return <SortAlgorithm>localStorage.getItem(`mx_tagSort_${tagId}`);\n    }\n\n    // logic must match calculateListOrder\n    private calculateTagSorting(tagId: TagID): SortAlgorithm {\n        const isDefaultRecent = tagId === DefaultTagID.Invite || tagId === DefaultTagID.DM;\n        const defaultSort = isDefaultRecent ? SortAlgorithm.Recent : SortAlgorithm.Alphabetic;\n        const settingAlphabetical = SettingsStore.getValue(\"RoomList.orderAlphabetically\", null, true);\n        const definedSort = this.getTagSorting(tagId);\n        const storedSort = this.getStoredTagSorting(tagId);\n\n        // We use the following order to determine which of the 4 flags to use:\n        // Stored > Settings > Defined > Default\n\n        let tagSort = defaultSort;\n        if (storedSort) {\n            tagSort = storedSort;\n        } else if (!isNullOrUndefined(settingAlphabetical)) {\n            tagSort = settingAlphabetical ? SortAlgorithm.Alphabetic : SortAlgorithm.Recent;\n        } else if (definedSort) {\n            tagSort = definedSort;\n        } // else default (already set)\n\n        return tagSort;\n    }\n\n    public setListOrder(tagId: TagID, order: ListAlgorithm) {\n        this.setAndPersistListOrder(tagId, order);\n        this.updateFn.trigger();\n    }\n\n    private setAndPersistListOrder(tagId: TagID, order: ListAlgorithm) {\n        this.algorithm.setListOrdering(tagId, order);\n        // TODO: Per-account? https://github.com/vector-im/element-web/issues/14114\n        localStorage.setItem(`mx_listOrder_${tagId}`, order);\n    }\n\n    public getListOrder(tagId: TagID): ListAlgorithm {\n        return this.algorithm.getListOrdering(tagId);\n    }\n\n    // noinspection JSMethodCanBeStatic\n    private getStoredListOrder(tagId: TagID): ListAlgorithm {\n        // TODO: Per-account? https://github.com/vector-im/element-web/issues/14114\n        return <ListAlgorithm>localStorage.getItem(`mx_listOrder_${tagId}`);\n    }\n\n    // logic must match calculateTagSorting\n    private calculateListOrder(tagId: TagID): ListAlgorithm {\n        const defaultOrder = ListAlgorithm.Natural;\n        const settingImportance = SettingsStore.getValue(\"RoomList.orderByImportance\", null, true);\n        const definedOrder = this.getListOrder(tagId);\n        const storedOrder = this.getStoredListOrder(tagId);\n\n        // We use the following order to determine which of the 4 flags to use:\n        // Stored > Settings > Defined > Default\n\n        let listOrder = defaultOrder;\n        if (storedOrder) {\n            listOrder = storedOrder;\n        } else if (!isNullOrUndefined(settingImportance)) {\n            listOrder = settingImportance ? ListAlgorithm.Importance : ListAlgorithm.Natural;\n        } else if (definedOrder) {\n            listOrder = definedOrder;\n        } // else default (already set)\n\n        return listOrder;\n    }\n\n    private updateAlgorithmInstances() {\n        // We'll require an update, so mark for one. Marking now also prevents the calls\n        // to setTagSorting and setListOrder from causing triggers.\n        this.updateFn.mark();\n\n        for (const tag of Object.keys(this.orderedLists)) {\n            const definedSort = this.getTagSorting(tag);\n            const definedOrder = this.getListOrder(tag);\n\n            const tagSort = this.calculateTagSorting(tag);\n            const listOrder = this.calculateListOrder(tag);\n\n            if (tagSort !== definedSort) {\n                this.setAndPersistTagSorting(tag, tagSort);\n            }\n            if (listOrder !== definedOrder) {\n                this.setAndPersistListOrder(tag, listOrder);\n            }\n        }\n    }\n\n    private onAlgorithmListUpdated = (forceUpdate: boolean) => {\n        this.updateFn.mark();\n        if (forceUpdate) this.updateFn.trigger();\n    };\n\n    private onAlgorithmFilterUpdated = () => {\n        // The filter can happen off-cycle, so trigger an update. The filter will have\n        // already caused a mark.\n        this.updateFn.trigger();\n    };\n\n    private onPrefilterUpdated = async () => {\n        await this.recalculatePrefiltering();\n        this.updateFn.trigger();\n    };\n\n    private getPlausibleRooms(): Room[] {\n        if (!this.matrixClient) return [];\n\n        let rooms = this.matrixClient.getVisibleRooms().filter(r => VisibilityProvider.instance.isRoomVisible(r));\n\n        if (this.prefilterConditions.length > 0) {\n            rooms = rooms.filter(r => {\n                for (const filter of this.prefilterConditions) {\n                    if (!filter.isVisible(r)) {\n                        return false;\n                    }\n                }\n                return true;\n            });\n        }\n\n        return rooms;\n    }\n\n    /**\n     * Regenerates the room whole room list, discarding any previous results.\n     *\n     * Note: This is only exposed externally for the tests. Do not call this from within\n     * the app.\n     * @param trigger Set to false to prevent a list update from being sent. Should only\n     * be used if the calling code will manually trigger the update.\n     */\n    public regenerateAllLists({ trigger = true }) {\n        logger.warn(\"Regenerating all room lists\");\n\n        const rooms = this.getPlausibleRooms();\n\n        const sorts: ITagSortingMap = {};\n        const orders: IListOrderingMap = {};\n        const allTags = [...OrderedDefaultTagIDs];\n        for (const tagId of allTags) {\n            sorts[tagId] = this.calculateTagSorting(tagId);\n            orders[tagId] = this.calculateListOrder(tagId);\n\n            RoomListLayoutStore.instance.ensureLayoutExists(tagId);\n        }\n\n        this.algorithm.populateTags(sorts, orders);\n        this.algorithm.setKnownRooms(rooms);\n\n        this.initialListsGenerated = true;\n\n        if (trigger) this.updateFn.trigger();\n    }\n\n    /**\n     * Adds a filter condition to the room list store. Filters may be applied async,\n     * and thus might not cause an update to the store immediately.\n     * @param {IFilterCondition} filter The filter condition to add.\n     */\n    public async addFilter(filter: IFilterCondition): Promise<void> {\n        let promise = Promise.resolve();\n        filter.on(FILTER_CHANGED, this.onPrefilterUpdated);\n        this.prefilterConditions.push(filter);\n        promise = this.recalculatePrefiltering();\n        promise.then(() => this.updateFn.trigger());\n    }\n\n    /**\n     * Removes a filter condition from the room list store. If the filter was\n     * not previously added to the room list store, this will no-op. The effects\n     * of removing a filter may be applied async and therefore might not cause\n     * an update right away.\n     * @param {IFilterCondition} filter The filter condition to remove.\n     */\n    public removeFilter(filter: IFilterCondition): void {\n        let promise = Promise.resolve();\n        let removed = false;\n        const idx = this.prefilterConditions.indexOf(filter);\n        if (idx >= 0) {\n            filter.off(FILTER_CHANGED, this.onPrefilterUpdated);\n            this.prefilterConditions.splice(idx, 1);\n            promise = this.recalculatePrefiltering();\n            removed = true;\n        }\n\n        if (removed) {\n            promise.then(() => this.updateFn.trigger());\n        }\n    }\n\n    /**\n     * Gets the tags for a room identified by the store. The returned set\n     * should never be empty, and will contain DefaultTagID.Untagged if\n     * the store is not aware of any tags.\n     * @param room The room to get the tags for.\n     * @returns The tags for the room.\n     */\n    public getTagsForRoom(room: Room): TagID[] {\n        const algorithmTags = this.algorithm.getTagsForRoom(room);\n        if (!algorithmTags) return [DefaultTagID.Untagged];\n        return algorithmTags;\n    }\n\n    /**\n     * Manually update a room with a given cause. This should only be used if the\n     * room list store would otherwise be incapable of doing the update itself. Note\n     * that this may race with the room list's regular operation.\n     * @param {Room} room The room to update.\n     * @param {RoomUpdateCause} cause The cause to update for.\n     */\n    public async manualRoomUpdate(room: Room, cause: RoomUpdateCause) {\n        await this.handleRoomUpdate(room, cause);\n        this.updateFn.trigger();\n    }\n}\n\nexport default class RoomListStore {\n    private static internalInstance: Interface;\n\n    public static get instance(): Interface {\n        if (!RoomListStore.internalInstance) {\n            RoomListStore.internalInstance = new RoomListStoreClass();\n        }\n\n        return RoomListStore.internalInstance;\n    }\n}\n\nwindow.mxRoomListStore = RoomListStore.instance;\n"],"mappings":"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"}