{"version":3,"file":"SetupEncryptionStore.js","names":["Phase","SetupEncryptionStore","EventEmitter","userId","MatrixClientPeg","get","getUserId","publicKeysTrusted","getCrossSigningId","phase","Done","emit","request","setActiveVerificationRequest","verificationRequest","cancelled","off","VerificationRequestEvent","Change","onVerificationRequestChange","VERIF_PHASE_DONE","Busy","sharedInstance","window","mxSetupEncryptionStore","start","started","Loading","backupInfo","keyId","keyInfo","cli","on","CryptoEvent","VerificationRequest","onVerificationRequest","UserTrustStatusChanged","onUserTrustStatusChanged","requestsInProgress","getVerificationRequestsToDeviceInProgress","length","fetchKeyInfo","stop","removeListener","keys","isSecretStored","Object","dehydratedDevice","getDehydratedDevice","ownUserId","crossSigningInfo","getStoredCrossSigningForUser","hasDevicesToVerifyAgainst","getStoredDevicesForUser","some","device","getIdentityKey","deviceId","device_id","checkDeviceTrust","isCrossSigningVerified","Intro","usePassPhrase","getKeyBackupVersion","Promise","resolve","reject","accessSecretStorage","checkOwnCrossSigningTrust","restoreKeyBackupWithSecretStorage","catch","e","AccessCancelledError","logger","log","skip","ConfirmSkip","skipConfirm","Finished","returnAfterSkip","reset","ConfirmReset","resetConfirm","bootstrapCrossSigning","authUploadDeviceSigningKeys","makeRequest","finished","Modal","createDialog","InteractiveAuthDialog","title","_t","matrixClient","confirmed","Error","setupNewCrossSigning","error","returnAfterReset","done","crypto","cancelAndResendAllOutgoingKeyRequests","otherUserId","accept","lostKeys"],"sources":["../../src/stores/SetupEncryptionStore.ts"],"sourcesContent":["/*\nCopyright 2020 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport EventEmitter from 'events';\nimport {\n    PHASE_DONE as VERIF_PHASE_DONE,\n    VerificationRequest,\n    VerificationRequestEvent,\n} from \"matrix-js-sdk/src/crypto/verification/request/VerificationRequest\";\nimport { IKeyBackupInfo } from \"matrix-js-sdk/src/crypto/keybackup\";\nimport { ISecretStorageKeyInfo } from \"matrix-js-sdk/src/crypto/api\";\nimport { logger } from \"matrix-js-sdk/src/logger\";\nimport { CryptoEvent } from \"matrix-js-sdk/src/crypto\";\n\nimport { MatrixClientPeg } from '../MatrixClientPeg';\nimport { AccessCancelledError, accessSecretStorage } from '../SecurityManager';\nimport Modal from '../Modal';\nimport InteractiveAuthDialog from '../components/views/dialogs/InteractiveAuthDialog';\nimport { _t } from '../languageHandler';\n\nexport enum Phase {\n    Loading = 0,\n    Intro = 1,\n    Busy = 2,\n    Done = 3, // final done stage, but still showing UX\n    ConfirmSkip = 4,\n    Finished = 5, // UX can be closed\n    ConfirmReset = 6,\n}\n\nexport class SetupEncryptionStore extends EventEmitter {\n    private started: boolean;\n    public phase: Phase;\n    public verificationRequest: VerificationRequest;\n    public backupInfo: IKeyBackupInfo;\n    public keyId: string;\n    public keyInfo: ISecretStorageKeyInfo;\n    public hasDevicesToVerifyAgainst: boolean;\n\n    public static sharedInstance() {\n        if (!window.mxSetupEncryptionStore) window.mxSetupEncryptionStore = new SetupEncryptionStore();\n        return window.mxSetupEncryptionStore;\n    }\n\n    public start(): void {\n        if (this.started) {\n            return;\n        }\n        this.started = true;\n        this.phase = Phase.Loading;\n        this.verificationRequest = null;\n        this.backupInfo = null;\n\n        // ID of the key that the secrets we want are encrypted with\n        this.keyId = null;\n        // Descriptor of the key that the secrets we want are encrypted with\n        this.keyInfo = null;\n\n        const cli = MatrixClientPeg.get();\n        cli.on(CryptoEvent.VerificationRequest, this.onVerificationRequest);\n        cli.on(CryptoEvent.UserTrustStatusChanged, this.onUserTrustStatusChanged);\n\n        const requestsInProgress = cli.getVerificationRequestsToDeviceInProgress(cli.getUserId());\n        if (requestsInProgress.length) {\n            // If there are multiple, we take the most recent. Equally if the user sends another request from\n            // another device after this screen has been shown, we'll switch to the new one, so this\n            // generally doesn't support multiple requests.\n            this.setActiveVerificationRequest(requestsInProgress[requestsInProgress.length - 1]);\n        }\n\n        this.fetchKeyInfo();\n    }\n\n    public stop(): void {\n        if (!this.started) {\n            return;\n        }\n        this.started = false;\n        this.verificationRequest?.off(VerificationRequestEvent.Change, this.onVerificationRequestChange);\n        if (MatrixClientPeg.get()) {\n            MatrixClientPeg.get().removeListener(CryptoEvent.VerificationRequest, this.onVerificationRequest);\n            MatrixClientPeg.get().removeListener(CryptoEvent.UserTrustStatusChanged, this.onUserTrustStatusChanged);\n        }\n    }\n\n    public async fetchKeyInfo(): Promise<void> {\n        if (!this.started) return; // bail if we were stopped\n        const cli = MatrixClientPeg.get();\n        const keys = await cli.isSecretStored('m.cross_signing.master');\n        if (keys === null || Object.keys(keys).length === 0) {\n            this.keyId = null;\n            this.keyInfo = null;\n        } else {\n            // If the secret is stored under more than one key, we just pick an arbitrary one\n            this.keyId = Object.keys(keys)[0];\n            this.keyInfo = keys[this.keyId];\n        }\n\n        // do we have any other verified devices which are E2EE which we can verify against?\n        const dehydratedDevice = await cli.getDehydratedDevice();\n        const ownUserId = cli.getUserId();\n        const crossSigningInfo = cli.getStoredCrossSigningForUser(ownUserId);\n        this.hasDevicesToVerifyAgainst = cli.getStoredDevicesForUser(ownUserId).some(\n            device =>\n                device.getIdentityKey() &&\n                (!dehydratedDevice || (device.deviceId != dehydratedDevice.device_id)) &&\n                crossSigningInfo.checkDeviceTrust(\n                    crossSigningInfo,\n                    device,\n                    false,\n                    true,\n                ).isCrossSigningVerified(),\n        );\n\n        this.phase = Phase.Intro;\n        this.emit(\"update\");\n    }\n\n    public async usePassPhrase(): Promise<void> {\n        this.phase = Phase.Busy;\n        this.emit(\"update\");\n        const cli = MatrixClientPeg.get();\n        try {\n            const backupInfo = await cli.getKeyBackupVersion();\n            this.backupInfo = backupInfo;\n            this.emit(\"update\");\n            // The control flow is fairly twisted here...\n            // For the purposes of completing security, we only wait on getting\n            // as far as the trust check and then show a green shield.\n            // We also begin the key backup restore as well, which we're\n            // awaiting inside `accessSecretStorage` only so that it keeps your\n            // passphase cached for that work. This dialog itself will only wait\n            // on the first trust check, and the key backup restore will happen\n            // in the background.\n            await new Promise((resolve: (value?: unknown) => void, reject: (reason?: any) => void) => {\n                accessSecretStorage(async () => {\n                    await cli.checkOwnCrossSigningTrust();\n                    resolve();\n                    if (backupInfo) {\n                        // A complete restore can take many minutes for large\n                        // accounts / slow servers, so we allow the dialog\n                        // to advance before this.\n                        await cli.restoreKeyBackupWithSecretStorage(backupInfo);\n                    }\n                }).catch(reject);\n            });\n\n            if (cli.getCrossSigningId()) {\n                this.phase = Phase.Done;\n                this.emit(\"update\");\n            }\n        } catch (e) {\n            if (!(e instanceof AccessCancelledError)) {\n                logger.log(e);\n            }\n            // this will throw if the user hits cancel, so ignore\n            this.phase = Phase.Intro;\n            this.emit(\"update\");\n        }\n    }\n\n    private onUserTrustStatusChanged = (userId: string) => {\n        if (userId !== MatrixClientPeg.get().getUserId()) return;\n        const publicKeysTrusted = MatrixClientPeg.get().getCrossSigningId();\n        if (publicKeysTrusted) {\n            this.phase = Phase.Done;\n            this.emit(\"update\");\n        }\n    };\n\n    public onVerificationRequest = (request: VerificationRequest): void => {\n        this.setActiveVerificationRequest(request);\n    };\n\n    public onVerificationRequestChange = (): void => {\n        if (this.verificationRequest.cancelled) {\n            this.verificationRequest.off(VerificationRequestEvent.Change, this.onVerificationRequestChange);\n            this.verificationRequest = null;\n            this.emit(\"update\");\n        } else if (this.verificationRequest.phase === VERIF_PHASE_DONE) {\n            this.verificationRequest.off(VerificationRequestEvent.Change, this.onVerificationRequestChange);\n            this.verificationRequest = null;\n            // At this point, the verification has finished, we just need to wait for\n            // cross signing to be ready to use, so wait for the user trust status to\n            // change (or change to DONE if it's already ready).\n            const publicKeysTrusted = MatrixClientPeg.get().getCrossSigningId();\n            this.phase = publicKeysTrusted ? Phase.Done : Phase.Busy;\n            this.emit(\"update\");\n        }\n    };\n\n    public skip(): void {\n        this.phase = Phase.ConfirmSkip;\n        this.emit(\"update\");\n    }\n\n    public skipConfirm(): void {\n        this.phase = Phase.Finished;\n        this.emit(\"update\");\n    }\n\n    public returnAfterSkip(): void {\n        this.phase = Phase.Intro;\n        this.emit(\"update\");\n    }\n\n    public reset(): void {\n        this.phase = Phase.ConfirmReset;\n        this.emit(\"update\");\n    }\n\n    public async resetConfirm(): Promise<void> {\n        try {\n            // If we've gotten here, the user presumably lost their\n            // secret storage key if they had one. Start by resetting\n            // secret storage and setting up a new recovery key, then\n            // create new cross-signing keys once that succeeds.\n            await accessSecretStorage(async () => {\n                const cli = MatrixClientPeg.get();\n                await cli.bootstrapCrossSigning({\n                    authUploadDeviceSigningKeys: async (makeRequest) => {\n                        const { finished } = Modal.createDialog(InteractiveAuthDialog, {\n                            title: _t(\"Setting up keys\"),\n                            matrixClient: cli,\n                            makeRequest,\n                        });\n                        const [confirmed] = await finished;\n                        if (!confirmed) {\n                            throw new Error(\"Cross-signing key upload auth canceled\");\n                        }\n                    },\n                    setupNewCrossSigning: true,\n                });\n                this.phase = Phase.Finished;\n            }, true);\n        } catch (e) {\n            logger.error(\"Error resetting cross-signing\", e);\n            this.phase = Phase.Intro;\n        }\n        this.emit(\"update\");\n    }\n\n    public returnAfterReset(): void {\n        this.phase = Phase.Intro;\n        this.emit(\"update\");\n    }\n\n    public done(): void {\n        this.phase = Phase.Finished;\n        this.emit(\"update\");\n        // async - ask other clients for keys, if necessary\n        MatrixClientPeg.get().crypto.cancelAndResendAllOutgoingKeyRequests();\n    }\n\n    private async setActiveVerificationRequest(request: VerificationRequest): Promise<void> {\n        if (!this.started) return; // bail if we were stopped\n        if (request.otherUserId !== MatrixClientPeg.get().getUserId()) return;\n\n        if (this.verificationRequest) {\n            this.verificationRequest.off(VerificationRequestEvent.Change, this.onVerificationRequestChange);\n        }\n        this.verificationRequest = request;\n        await request.accept();\n        request.on(VerificationRequestEvent.Change, this.onVerificationRequestChange);\n        this.emit(\"update\");\n    }\n\n    public lostKeys(): boolean {\n        return !this.hasDevicesToVerifyAgainst && !this.keyInfo;\n    }\n}\n"],"mappings":"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"}