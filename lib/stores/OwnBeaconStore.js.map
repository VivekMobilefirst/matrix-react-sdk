{"version":3,"file":"OwnBeaconStore.js","names":["isOwnBeacon","beacon","userId","beaconInfoOwner","OwnBeaconStoreEvent","MOVING_UPDATE_INTERVAL","STATIC_UPDATE_INTERVAL","BAIL_AFTER_CONSECUTIVE_ERROR_COUNT","CREATED_BEACONS_KEY","removeLocallyCreateBeaconEventId","eventId","ids","getLocallyCreatedBeaconEventIds","window","localStorage","setItem","JSON","stringify","filter","id","storeLocallyCreateBeaconEventId","parse","getItem","Array","isArray","Error","error","logger","OwnBeaconStore","AsyncStoreWithClient","constructor","defaultDispatcher","Map","roomId","getLiveBeaconIds","length","some","beaconHasLocationPublishError","beaconId","beaconLocationPublishErrorCounts","get","incrementBeaconLocationPublishErrorCount","publishCurrentLocationToBeacons","liveBeaconIds","beaconsByRoomId","has","beacons","beaconIdentifier","beaconInfo","live","updateBeaconEvent","beaconInfoId","_event","matrixClient","getUserId","addBeacon","checkLiveness","monitorLiveness","isLive","identifier","stopBeacon","emit","LivenessChange","roomState","member","membership","forEach","removeBeacon","delete","visibleRooms","getVisibleRooms","room","currentState","ownBeaconsArray","values","set","Set","add","destroy","locallyCreatedBeaconEventIds","prevLiveBeaconIds","includes","sort","sortBeaconsByLatestCreation","map","diff","arrayDiff","added","removed","isMonitoringLiveLocation","togglePollingLocation","beaconInfoContent","existingLiveBeaconIdsForRoom","Promise","all","event_id","doMaybeLocalRoomAction","actualRoomId","unstable_createLiveBeacon","startPollingLocation","stopPollingLocation","clearPositionWatch","watchPosition","onWatchedPosition","onGeolocationError","message","locationInterval","setInterval","lastPublishedPositionTimestamp","Date","now","MonitoringLivePosition","clearInterval","undefined","geolocationError","position","timedGeoPosition","mapGeolocationPositionToTimedGeo","publishLocationToBeacons","debouncedPublishLocationToBeacons","GeolocationError","Unavailable","PermissionDenied","getCurrentPosition","update","description","timeout","timestamp","assetType","updateContent","makeBeaconInfoContent","unstable_setLiveBeacon","hadError","beaconUpdateErrors","BeaconUpdateError","healthyLiveBeaconIds","sendLocationToBeacon","debounce","geoUri","content","makeBeaconContent","sendEvent","M_BEACON","name","isError","LocationPublishError","instance","internalInstance","onNotReady","removeListener","BeaconEvent","onBeaconLiveness","New","onNewBeacon","Update","onUpdateBeacon","Destroy","onDestroyBeacon","RoomStateEvent","Members","onRoomStateMembers","clear","onReady","on","initialiseBeaconState","onAction","payload"],"sources":["../../src/stores/OwnBeaconStore.ts"],"sourcesContent":["/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { debounce } from \"lodash\";\nimport {\n    Beacon,\n    BeaconIdentifier,\n    BeaconEvent,\n    MatrixEvent,\n    Room,\n    RoomMember,\n    RoomState,\n    RoomStateEvent,\n} from \"matrix-js-sdk/src/matrix\";\nimport {\n    BeaconInfoState, makeBeaconContent, makeBeaconInfoContent,\n} from \"matrix-js-sdk/src/content-helpers\";\nimport { MBeaconInfoEventContent, M_BEACON } from \"matrix-js-sdk/src/@types/beacon\";\nimport { logger } from \"matrix-js-sdk/src/logger\";\n\nimport defaultDispatcher from \"../dispatcher/dispatcher\";\nimport { ActionPayload } from \"../dispatcher/payloads\";\nimport { AsyncStoreWithClient } from \"./AsyncStoreWithClient\";\nimport { arrayDiff } from \"../utils/arrays\";\nimport {\n    ClearWatchCallback,\n    GeolocationError,\n    mapGeolocationPositionToTimedGeo,\n    sortBeaconsByLatestCreation,\n    TimedGeoUri,\n    watchPosition,\n} from \"../utils/beacon\";\nimport { getCurrentPosition } from \"../utils/beacon\";\nimport { doMaybeLocalRoomAction } from \"../utils/local-room\";\n\nconst isOwnBeacon = (beacon: Beacon, userId: string): boolean => beacon.beaconInfoOwner === userId;\n\nexport enum OwnBeaconStoreEvent {\n    LivenessChange = 'OwnBeaconStore.LivenessChange',\n    MonitoringLivePosition = 'OwnBeaconStore.MonitoringLivePosition',\n    LocationPublishError = 'LocationPublishError',\n    BeaconUpdateError = 'BeaconUpdateError',\n}\n\nconst MOVING_UPDATE_INTERVAL = 5000;\nconst STATIC_UPDATE_INTERVAL = 30000;\n\nconst BAIL_AFTER_CONSECUTIVE_ERROR_COUNT = 2;\n\ntype OwnBeaconStoreState = {\n    beacons: Map<BeaconIdentifier, Beacon>;\n    beaconLocationPublishErrorCounts: Map<BeaconIdentifier, number>;\n    beaconUpdateErrors: Map<BeaconIdentifier, Error>;\n    beaconsByRoomId: Map<Room['roomId'], Set<BeaconIdentifier>>;\n    liveBeaconIds: BeaconIdentifier[];\n};\n\nconst CREATED_BEACONS_KEY = 'mx_live_beacon_created_id';\nconst removeLocallyCreateBeaconEventId = (eventId: string): void => {\n    const ids = getLocallyCreatedBeaconEventIds();\n    window.localStorage.setItem(CREATED_BEACONS_KEY, JSON.stringify(ids.filter(id => id !== eventId)));\n};\nconst storeLocallyCreateBeaconEventId = (eventId: string): void => {\n    const ids = getLocallyCreatedBeaconEventIds();\n    window.localStorage.setItem(CREATED_BEACONS_KEY, JSON.stringify([...ids, eventId]));\n};\n\nconst getLocallyCreatedBeaconEventIds = (): string[] => {\n    let ids: string[];\n    try {\n        ids = JSON.parse(window.localStorage.getItem(CREATED_BEACONS_KEY) ?? '[]');\n        if (!Array.isArray(ids)) {\n            throw new Error('Invalid stored value');\n        }\n    } catch (error) {\n        logger.error('Failed to retrieve locally created beacon event ids', error);\n        ids = [];\n    }\n    return ids;\n};\nexport class OwnBeaconStore extends AsyncStoreWithClient<OwnBeaconStoreState> {\n    private static internalInstance = new OwnBeaconStore();\n    // users beacons, keyed by event type\n    public readonly beacons = new Map<BeaconIdentifier, Beacon>();\n    public readonly beaconsByRoomId = new Map<Room['roomId'], Set<BeaconIdentifier>>();\n    /**\n     * Track over the wire errors for published positions\n     * Counts consecutive wire errors per beacon\n     * Reset on successful publish of location\n     */\n    public readonly beaconLocationPublishErrorCounts = new Map<BeaconIdentifier, number>();\n    public readonly beaconUpdateErrors = new Map<BeaconIdentifier, Error>();\n    /**\n     * ids of live beacons\n     * ordered by creation time descending\n     */\n    private liveBeaconIds: BeaconIdentifier[] = [];\n    private locationInterval: number;\n    private geolocationError: GeolocationError | undefined;\n    private clearPositionWatch: ClearWatchCallback | undefined;\n    /**\n     * Track when the last position was published\n     * So we can manually get position on slow interval\n     * when the target is stationary\n     */\n    private lastPublishedPositionTimestamp: number | undefined;\n\n    public constructor() {\n        super(defaultDispatcher);\n    }\n\n    public static get instance(): OwnBeaconStore {\n        return OwnBeaconStore.internalInstance;\n    }\n\n    /**\n     * True when we have live beacons\n     * and geolocation.watchPosition is active\n     */\n    public get isMonitoringLiveLocation(): boolean {\n        return !!this.clearPositionWatch;\n    }\n\n    protected async onNotReady() {\n        this.matrixClient.removeListener(BeaconEvent.LivenessChange, this.onBeaconLiveness);\n        this.matrixClient.removeListener(BeaconEvent.New, this.onNewBeacon);\n        this.matrixClient.removeListener(BeaconEvent.Update, this.onUpdateBeacon);\n        this.matrixClient.removeListener(BeaconEvent.Destroy, this.onDestroyBeacon);\n        this.matrixClient.removeListener(RoomStateEvent.Members, this.onRoomStateMembers);\n\n        this.beacons.forEach(beacon => beacon.destroy());\n\n        this.stopPollingLocation();\n        this.beacons.clear();\n        this.beaconsByRoomId.clear();\n        this.liveBeaconIds = [];\n        this.beaconLocationPublishErrorCounts.clear();\n        this.beaconUpdateErrors.clear();\n    }\n\n    protected async onReady(): Promise<void> {\n        this.matrixClient.on(BeaconEvent.LivenessChange, this.onBeaconLiveness);\n        this.matrixClient.on(BeaconEvent.New, this.onNewBeacon);\n        this.matrixClient.on(BeaconEvent.Update, this.onUpdateBeacon);\n        this.matrixClient.on(BeaconEvent.Destroy, this.onDestroyBeacon);\n        this.matrixClient.on(RoomStateEvent.Members, this.onRoomStateMembers);\n\n        this.initialiseBeaconState();\n    }\n\n    protected async onAction(payload: ActionPayload): Promise<void> {\n        // we don't actually do anything here\n    }\n\n    public hasLiveBeacons = (roomId?: string): boolean => {\n        return !!this.getLiveBeaconIds(roomId).length;\n    };\n\n    /**\n     * Some live beacon has a wire error\n     * Optionally filter by room\n     */\n    public hasLocationPublishErrors = (roomId?: string): boolean => {\n        return this.getLiveBeaconIds(roomId).some(this.beaconHasLocationPublishError);\n    };\n\n    /**\n     * If a beacon has failed to publish position\n     * past the allowed consecutive failure count (BAIL_AFTER_CONSECUTIVE_ERROR_COUNT)\n     * Then consider it to have an error\n     */\n    public beaconHasLocationPublishError = (beaconId: string): boolean => {\n        return this.beaconLocationPublishErrorCounts.get(beaconId) >= BAIL_AFTER_CONSECUTIVE_ERROR_COUNT;\n    };\n\n    public resetLocationPublishError = (beaconId: string): void => {\n        this.incrementBeaconLocationPublishErrorCount(beaconId, false);\n\n        // always publish to all live beacons together\n        // instead of just one that was changed\n        // to keep lastPublishedTimestamp simple\n        // and extra published locations don't hurt\n        this.publishCurrentLocationToBeacons();\n    };\n\n    public getLiveBeaconIds = (roomId?: string): string[] => {\n        if (!roomId) {\n            return this.liveBeaconIds;\n        }\n        return this.liveBeaconIds.filter(beaconId => this.beaconsByRoomId.get(roomId)?.has(beaconId));\n    };\n\n    public getLiveBeaconIdsWithLocationPublishError = (roomId?: string): string[] => {\n        return this.getLiveBeaconIds(roomId).filter(this.beaconHasLocationPublishError);\n    };\n\n    public getBeaconById = (beaconId: string): Beacon | undefined => {\n        return this.beacons.get(beaconId);\n    };\n\n    public stopBeacon = async (beaconIdentifier: string): Promise<void> => {\n        const beacon = this.beacons.get(beaconIdentifier);\n        // if no beacon, or beacon is already explicitly set isLive: false\n        // do nothing\n        if (!beacon?.beaconInfo?.live) {\n            return;\n        }\n\n        await this.updateBeaconEvent(beacon, { live: false });\n        // prune from local store\n        removeLocallyCreateBeaconEventId(beacon.beaconInfoId);\n    };\n\n    /**\n     * Listeners\n     */\n\n    private onNewBeacon = (_event: MatrixEvent, beacon: Beacon): void => {\n        if (!isOwnBeacon(beacon, this.matrixClient.getUserId())) {\n            return;\n        }\n        this.addBeacon(beacon);\n        this.checkLiveness();\n    };\n\n    /**\n     * This will be called when a beacon is replaced\n     */\n    private onUpdateBeacon = (_event: MatrixEvent, beacon: Beacon): void => {\n        if (!isOwnBeacon(beacon, this.matrixClient.getUserId())) {\n            return;\n        }\n\n        this.checkLiveness();\n        beacon.monitorLiveness();\n    };\n\n    private onDestroyBeacon = (beaconIdentifier: BeaconIdentifier): void => {\n        // check if we care about this beacon\n        if (!this.beacons.has(beaconIdentifier)) {\n            return;\n        }\n\n        this.checkLiveness();\n    };\n\n    private onBeaconLiveness = (isLive: boolean, beacon: Beacon): void => {\n        // check if we care about this beacon\n        if (!this.beacons.has(beacon.identifier)) {\n            return;\n        }\n\n        // beacon expired, update beacon to un-alive state\n        if (!isLive) {\n            this.stopBeacon(beacon.identifier);\n        }\n\n        this.checkLiveness();\n\n        this.emit(OwnBeaconStoreEvent.LivenessChange, this.getLiveBeaconIds());\n    };\n\n    /**\n     * Check for changes in membership in rooms with beacons\n     * and stop monitoring beacons in rooms user is no longer member of\n     */\n    private onRoomStateMembers = (_event: MatrixEvent, roomState: RoomState, member: RoomMember): void => {\n        // no beacons for this room, ignore\n        if (\n            !this.beaconsByRoomId.has(roomState.roomId) ||\n            member.userId !== this.matrixClient.getUserId()\n        ) {\n            return;\n        }\n\n        // TODO check powerlevels here\n        // in PSF-797\n\n        // stop watching beacons in rooms where user is no longer a member\n        if (member.membership === 'leave' || member.membership === 'ban') {\n            this.beaconsByRoomId.get(roomState.roomId)?.forEach(this.removeBeacon);\n            this.beaconsByRoomId.delete(roomState.roomId);\n        }\n    };\n\n    /**\n     * State management\n     */\n\n    /**\n     * Live beacon ids that do not have wire errors\n     */\n    private get healthyLiveBeaconIds() {\n        return this.liveBeaconIds.filter(beaconId =>\n            !this.beaconHasLocationPublishError(beaconId) &&\n            !this.beaconUpdateErrors.has(beaconId),\n        );\n    }\n\n    private initialiseBeaconState = () => {\n        const userId = this.matrixClient.getUserId();\n        const visibleRooms = this.matrixClient.getVisibleRooms();\n\n        visibleRooms\n            .forEach(room => {\n                const roomState = room.currentState;\n                const beacons = roomState.beacons;\n                const ownBeaconsArray = [...beacons.values()].filter(beacon => isOwnBeacon(beacon, userId));\n                ownBeaconsArray.forEach(beacon => this.addBeacon(beacon));\n            });\n\n        this.checkLiveness();\n    };\n\n    private addBeacon = (beacon: Beacon): void => {\n        this.beacons.set(beacon.identifier, beacon);\n\n        if (!this.beaconsByRoomId.has(beacon.roomId)) {\n            this.beaconsByRoomId.set(beacon.roomId, new Set<string>());\n        }\n\n        this.beaconsByRoomId.get(beacon.roomId).add(beacon.identifier);\n\n        beacon.monitorLiveness();\n    };\n\n    /**\n     * Remove listeners for a given beacon\n     * remove from state\n     * and update liveness if changed\n     */\n    private removeBeacon = (beaconId: string): void => {\n        if (!this.beacons.has(beaconId)) {\n            return;\n        }\n        this.beacons.get(beaconId).destroy();\n        this.beacons.delete(beaconId);\n\n        this.checkLiveness();\n    };\n\n    private checkLiveness = (): void => {\n        const locallyCreatedBeaconEventIds = getLocallyCreatedBeaconEventIds();\n        const prevLiveBeaconIds = this.getLiveBeaconIds();\n        this.liveBeaconIds = [...this.beacons.values()]\n            .filter(beacon =>\n                beacon.isLive &&\n                // only beacons created on this device should be shared to\n                locallyCreatedBeaconEventIds.includes(beacon.beaconInfoId),\n            )\n            .sort(sortBeaconsByLatestCreation)\n            .map(beacon => beacon.identifier);\n\n        const diff = arrayDiff(prevLiveBeaconIds, this.liveBeaconIds);\n\n        if (diff.added.length || diff.removed.length) {\n            this.emit(OwnBeaconStoreEvent.LivenessChange, this.liveBeaconIds);\n        }\n\n        // publish current location immediately\n        // when there are new live beacons\n        // and we already have a live monitor\n        // so first position is published quickly\n        // even when target is stationary\n        //\n        // when there is no existing live monitor\n        // it will be created below by togglePollingLocation\n        // and publish first position quickly\n        if (diff.added.length && this.isMonitoringLiveLocation) {\n            this.publishCurrentLocationToBeacons();\n        }\n\n        // if overall liveness changed\n        if (!!prevLiveBeaconIds?.length !== !!this.liveBeaconIds.length) {\n            this.togglePollingLocation();\n        }\n    };\n\n    public createLiveBeacon = async (\n        roomId: Room['roomId'],\n        beaconInfoContent: MBeaconInfoEventContent,\n    ): Promise<void> => {\n        // explicitly stop any live beacons this user has\n        // to ensure they remain stopped\n        // if the new replacing beacon is redacted\n        const existingLiveBeaconIdsForRoom = this.getLiveBeaconIds(roomId);\n        await Promise.all(existingLiveBeaconIdsForRoom.map(beaconId => this.stopBeacon(beaconId)));\n\n        // eslint-disable-next-line camelcase\n        const { event_id } = await doMaybeLocalRoomAction(\n            roomId,\n            (actualRoomId: string) => this.matrixClient.unstable_createLiveBeacon(actualRoomId, beaconInfoContent),\n            this.matrixClient,\n        );\n\n        storeLocallyCreateBeaconEventId(event_id);\n    };\n\n    /**\n     * Geolocation\n     */\n\n    private togglePollingLocation = () => {\n        if (!!this.liveBeaconIds.length) {\n            this.startPollingLocation();\n        } else {\n            this.stopPollingLocation();\n        }\n    };\n\n    private startPollingLocation = async () => {\n        // clear any existing interval\n        this.stopPollingLocation();\n\n        try {\n            this.clearPositionWatch = watchPosition(this.onWatchedPosition, this.onGeolocationError);\n        } catch (error) {\n            this.onGeolocationError(error?.message);\n            // don't set locationInterval if geolocation failed to setup\n            return;\n        }\n\n        this.locationInterval = setInterval(() => {\n            if (!this.lastPublishedPositionTimestamp) {\n                return;\n            }\n            // if position was last updated STATIC_UPDATE_INTERVAL ms ago or more\n            // get our position and publish it\n            if (this.lastPublishedPositionTimestamp <= Date.now() - STATIC_UPDATE_INTERVAL) {\n                this.publishCurrentLocationToBeacons();\n            }\n        }, STATIC_UPDATE_INTERVAL);\n\n        this.emit(OwnBeaconStoreEvent.MonitoringLivePosition);\n    };\n\n    private stopPollingLocation = () => {\n        clearInterval(this.locationInterval);\n        this.locationInterval = undefined;\n        this.lastPublishedPositionTimestamp = undefined;\n        this.geolocationError = undefined;\n\n        if (this.clearPositionWatch) {\n            this.clearPositionWatch();\n            this.clearPositionWatch = undefined;\n        }\n\n        this.emit(OwnBeaconStoreEvent.MonitoringLivePosition);\n    };\n\n    private onWatchedPosition = (position: GeolocationPosition) => {\n        const timedGeoPosition = mapGeolocationPositionToTimedGeo(position);\n\n        // if this is our first position, publish immediately\n        if (!this.lastPublishedPositionTimestamp) {\n            this.publishLocationToBeacons(timedGeoPosition);\n        } else {\n            this.debouncedPublishLocationToBeacons(timedGeoPosition);\n        }\n    };\n\n    private onGeolocationError = async (error: GeolocationError): Promise<void> => {\n        this.geolocationError = error;\n        logger.error('Geolocation failed', this.geolocationError);\n\n        // other errors are considered non-fatal\n        // and self recovering\n        if (![\n            GeolocationError.Unavailable,\n            GeolocationError.PermissionDenied,\n        ].includes(error)) {\n            return;\n        }\n\n        this.stopPollingLocation();\n        // kill live beacons when location permissions are revoked\n        await Promise.all(this.liveBeaconIds.map(this.stopBeacon));\n    };\n\n    /**\n     * Gets the current location\n     * (as opposed to using watched location)\n     * and publishes it to all live beacons\n     */\n    private publishCurrentLocationToBeacons = async () => {\n        try {\n            const position = await getCurrentPosition();\n            this.publishLocationToBeacons(mapGeolocationPositionToTimedGeo(position));\n        } catch (error) {\n            this.onGeolocationError(error?.message);\n        }\n    };\n\n    /**\n     * MatrixClient api\n     */\n\n    /**\n     * Updates beacon with provided content update\n     * Records error in beaconUpdateErrors\n     * rethrows\n     */\n    private updateBeaconEvent = async (beacon: Beacon, update: Partial<BeaconInfoState>): Promise<void> => {\n        const { description, timeout, timestamp, live, assetType } = {\n            ...beacon.beaconInfo,\n            ...update,\n        };\n\n        const updateContent = makeBeaconInfoContent(timeout,\n            live,\n            description,\n            assetType,\n            timestamp,\n        );\n\n        try {\n            await this.matrixClient.unstable_setLiveBeacon(beacon.roomId, updateContent);\n            // cleanup any errors\n            const hadError = this.beaconUpdateErrors.has(beacon.identifier);\n            if (hadError) {\n                this.beaconUpdateErrors.delete(beacon.identifier);\n                this.emit(OwnBeaconStoreEvent.BeaconUpdateError, beacon.identifier, false);\n            }\n        } catch (error) {\n            logger.error('Failed to update beacon', error);\n            this.beaconUpdateErrors.set(beacon.identifier, error);\n            this.emit(OwnBeaconStoreEvent.BeaconUpdateError, beacon.identifier, true);\n\n            throw error;\n        }\n    };\n\n    /**\n     * Sends m.location events to all live beacons\n     * Sets last published beacon\n     */\n    private publishLocationToBeacons = async (position: TimedGeoUri) => {\n        this.lastPublishedPositionTimestamp = Date.now();\n        await Promise.all(this.healthyLiveBeaconIds.map(beaconId =>\n            this.sendLocationToBeacon(this.beacons.get(beaconId), position)),\n        );\n    };\n\n    private debouncedPublishLocationToBeacons = debounce(this.publishLocationToBeacons, MOVING_UPDATE_INTERVAL);\n\n    /**\n     * Sends m.location event to referencing given beacon\n     */\n    private sendLocationToBeacon = async (beacon: Beacon, { geoUri, timestamp }: TimedGeoUri) => {\n        const content = makeBeaconContent(geoUri, timestamp, beacon.beaconInfoId);\n        try {\n            await this.matrixClient.sendEvent(beacon.roomId, M_BEACON.name, content);\n            this.incrementBeaconLocationPublishErrorCount(beacon.identifier, false);\n        } catch (error) {\n            logger.error(error);\n            this.incrementBeaconLocationPublishErrorCount(beacon.identifier, true);\n        }\n    };\n\n    /**\n     * Manage beacon wire error count\n     * - clear count for beacon when not error\n     * - increment count for beacon when is error\n     * - emit if beacon error count crossed threshold\n     */\n    private incrementBeaconLocationPublishErrorCount = (beaconId: string, isError: boolean): void => {\n        const hadError = this.beaconHasLocationPublishError(beaconId);\n\n        if (isError) {\n            // increment error count\n            this.beaconLocationPublishErrorCounts.set(\n                beaconId,\n                (this.beaconLocationPublishErrorCounts.get(beaconId) ?? 0) + 1,\n            );\n        } else {\n            // clear any error count\n            this.beaconLocationPublishErrorCounts.delete(beaconId);\n        }\n\n        if (this.beaconHasLocationPublishError(beaconId) !== hadError) {\n            this.emit(OwnBeaconStoreEvent.LocationPublishError, beaconId);\n        }\n    };\n}\n"],"mappings":"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"}