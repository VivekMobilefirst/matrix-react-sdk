{"version":3,"file":"Playback.js","names":["PlaybackState","PLAYBACK_WAVEFORM_SAMPLES","THUMBNAIL_WAVEFORM_SAMPLES","DEFAULT_WAVEFORM","arraySeed","makePlaybackWaveform","input","noiseWaveform","map","v","Math","abs","arrayRescale","arraySmoothingResample","Playback","EventEmitter","constructor","buf","seedWaveform","Decoding","SimpleObservable","context","suspend","emit","Stopped","fileSize","byteLength","createAudioContext","resampledWaveform","arrayFastResample","thumbnailWaveform","waveformObservable","update","clock","PlaybackClock","sizeBytes","waveform","waveformData","clockInfo","currentState","state","isPlaying","Playing","event","args","UPDATE_EVENT","destroy","stop","removeAllListeners","close","element","URL","revokeObjectURL","src","remove","prepare","logger","log","document","createElement","prom","Promise","resolve","reject","onloadeddata","onerror","e","createObjectURL","Blob","audioBuf","decodeAudioData","b","error","warn","wav","decodeOgg","Array","from","getChannelData","flagLoadTime","durationSeconds","duration","play","disconnectSource","makeNewSourceBuffer","source","start","resume","flagStart","disconnect","removeEventListener","onPlaybackEnd","createMediaElementSource","createBufferSource","buffer","addEventListener","connect","destination","pause","Paused","flagStop","toggle","skipTo","timeSeconds","clamp","now","currentTime","syncTo"],"sources":["../../src/audio/Playback.ts"],"sourcesContent":["/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport EventEmitter from \"events\";\nimport { SimpleObservable } from \"matrix-widget-api\";\nimport { logger } from \"matrix-js-sdk/src/logger\";\n\nimport { UPDATE_EVENT } from \"../stores/AsyncStore\";\nimport { arrayFastResample, arrayRescale, arraySeed, arraySmoothingResample } from \"../utils/arrays\";\nimport { IDestroyable } from \"../utils/IDestroyable\";\nimport { PlaybackClock } from \"./PlaybackClock\";\nimport { createAudioContext, decodeOgg } from \"./compat\";\nimport { clamp } from \"../utils/numbers\";\n\nexport enum PlaybackState {\n    Decoding = \"decoding\",\n    Stopped = \"stopped\", // no progress on timeline\n    Paused = \"paused\", // some progress on timeline\n    Playing = \"playing\", // active progress through timeline\n}\n\nexport const PLAYBACK_WAVEFORM_SAMPLES = 39;\nconst THUMBNAIL_WAVEFORM_SAMPLES = 100; // arbitrary: [30,120]\nexport const DEFAULT_WAVEFORM = arraySeed(0, PLAYBACK_WAVEFORM_SAMPLES);\n\nfunction makePlaybackWaveform(input: number[]): number[] {\n    // First, convert negative amplitudes to positive so we don't detect zero as \"noisy\".\n    const noiseWaveform = input.map(v => Math.abs(v));\n\n    // Then, we'll resample the waveform using a smoothing approach so we can keep the same rough shape.\n    // We also rescale the waveform to be 0-1 so we end up with a clamped waveform to rely upon.\n    return arrayRescale(arraySmoothingResample(noiseWaveform, PLAYBACK_WAVEFORM_SAMPLES), 0, 1);\n}\n\nexport class Playback extends EventEmitter implements IDestroyable {\n    /**\n     * Stable waveform for representing a thumbnail of the media. Values are\n     * guaranteed to be between zero and one, inclusive.\n     */\n    public readonly thumbnailWaveform: number[];\n\n    private readonly context: AudioContext;\n    private source: AudioBufferSourceNode | MediaElementAudioSourceNode;\n    private state = PlaybackState.Decoding;\n    private audioBuf: AudioBuffer;\n    private element: HTMLAudioElement;\n    private resampledWaveform: number[];\n    private waveformObservable = new SimpleObservable<number[]>();\n    private readonly clock: PlaybackClock;\n    private readonly fileSize: number;\n\n    /**\n     * Creates a new playback instance from a buffer.\n     * @param {ArrayBuffer} buf The buffer containing the sound sample.\n     * @param {number[]} seedWaveform Optional seed waveform to present until the proper waveform\n     * can be calculated. Contains values between zero and one, inclusive.\n     */\n    constructor(private buf: ArrayBuffer, seedWaveform = DEFAULT_WAVEFORM) {\n        super();\n        // Capture the file size early as reading the buffer will result in a 0-length buffer left behind\n        this.fileSize = this.buf.byteLength;\n        this.context = createAudioContext();\n        this.resampledWaveform = arrayFastResample(seedWaveform ?? DEFAULT_WAVEFORM, PLAYBACK_WAVEFORM_SAMPLES);\n        this.thumbnailWaveform = arrayFastResample(seedWaveform ?? DEFAULT_WAVEFORM, THUMBNAIL_WAVEFORM_SAMPLES);\n        this.waveformObservable.update(this.resampledWaveform);\n        this.clock = new PlaybackClock(this.context);\n    }\n\n    /**\n     * Size of the audio clip in bytes. May be zero if unknown. This is updated\n     * when the playback goes through phase changes.\n     */\n    public get sizeBytes(): number {\n        return this.fileSize;\n    }\n\n    /**\n     * Stable waveform for the playback. Values are guaranteed to be between\n     * zero and one, inclusive.\n     */\n    public get waveform(): number[] {\n        return this.resampledWaveform;\n    }\n\n    public get waveformData(): SimpleObservable<number[]> {\n        return this.waveformObservable;\n    }\n\n    public get clockInfo(): PlaybackClock {\n        return this.clock;\n    }\n\n    public get currentState(): PlaybackState {\n        return this.state;\n    }\n\n    public get isPlaying(): boolean {\n        return this.currentState === PlaybackState.Playing;\n    }\n\n    public emit(event: PlaybackState, ...args: any[]): boolean {\n        this.state = event;\n        super.emit(event, ...args);\n        super.emit(UPDATE_EVENT, event, ...args);\n        return true; // we don't ever care if the event had listeners, so just return \"yes\"\n    }\n\n    public destroy() {\n        // Dev note: It's critical that we call stop() during cleanup to ensure that downstream callers\n        // are aware of the final clock position before the user triggered an unload.\n        // noinspection JSIgnoredPromiseFromCall - not concerned about being called async here\n        this.stop();\n        this.removeAllListeners();\n        this.clock.destroy();\n        this.waveformObservable.close();\n        if (this.element) {\n            URL.revokeObjectURL(this.element.src);\n            this.element.remove();\n        }\n    }\n\n    public async prepare() {\n        // don't attempt to decode the media again\n        // AudioContext.decodeAudioData detaches the array buffer `this.buf`\n        // meaning it cannot be re-read\n        if (this.state !== PlaybackState.Decoding) {\n            return;\n        }\n\n        // The point where we use an audio element is fairly arbitrary, though we don't want\n        // it to be too low. As of writing, voice messages want to show a waveform but audio\n        // messages do not. Using an audio element means we can't show a waveform preview, so\n        // we try to target the difference between a voice message file and large audio file.\n        // Overall, the point of this is to avoid memory-related issues due to storing a massive\n        // audio buffer in memory, as that can balloon to far greater than the input buffer's\n        // byte length.\n        if (this.buf.byteLength > 5 * 1024 * 1024) { // 5mb\n            logger.log(\"Audio file too large: processing through <audio /> element\");\n            this.element = document.createElement(\"AUDIO\") as HTMLAudioElement;\n            const prom = new Promise((resolve, reject) => {\n                this.element.onloadeddata = () => resolve(null);\n                this.element.onerror = (e) => reject(e);\n            });\n            this.element.src = URL.createObjectURL(new Blob([this.buf]));\n            await prom; // make sure the audio element is ready for us\n        } else {\n            // Safari compat: promise API not supported on this function\n            this.audioBuf = await new Promise((resolve, reject) => {\n                this.context.decodeAudioData(this.buf, b => resolve(b), async e => {\n                    try {\n                        // This error handler is largely for Safari as well, which doesn't support Opus/Ogg\n                        // very well.\n                        logger.error(\"Error decoding recording: \", e);\n                        logger.warn(\"Trying to re-encode to WAV instead...\");\n\n                        const wav = await decodeOgg(this.buf);\n\n                        // noinspection ES6MissingAwait - not needed when using callbacks\n                        this.context.decodeAudioData(wav, b => resolve(b), e => {\n                            logger.error(\"Still failed to decode recording: \", e);\n                            reject(e);\n                        });\n                    } catch (e) {\n                        logger.error(\"Caught decoding error:\", e);\n                        reject(e);\n                    }\n                });\n            });\n\n            // Update the waveform to the real waveform once we have channel data to use. We don't\n            // exactly trust the user-provided waveform to be accurate...\n            const waveform = Array.from(this.audioBuf.getChannelData(0));\n            this.resampledWaveform = makePlaybackWaveform(waveform);\n        }\n\n        this.waveformObservable.update(this.resampledWaveform);\n\n        this.clock.flagLoadTime(); // must happen first because setting the duration fires a clock update\n        this.clock.durationSeconds = this.element ? this.element.duration : this.audioBuf.duration;\n\n        // Signal that we're not decoding anymore. This is done last to ensure the clock is updated for\n        // when the downstream callers try to use it.\n        this.emit(PlaybackState.Stopped); // signal that we're not decoding anymore\n    }\n\n    private onPlaybackEnd = async () => {\n        await this.context.suspend();\n        this.emit(PlaybackState.Stopped);\n    };\n\n    public async play() {\n        // We can't restart a buffer source, so we need to create a new one if we hit the end\n        if (this.state === PlaybackState.Stopped) {\n            this.disconnectSource();\n            this.makeNewSourceBuffer();\n            if (this.element) {\n                await this.element.play();\n            } else {\n                (this.source as AudioBufferSourceNode).start();\n            }\n        }\n\n        // We use the context suspend/resume functions because it allows us to pause a source\n        // node, but that still doesn't help us when the source node runs out (see above).\n        await this.context.resume();\n        this.clock.flagStart();\n        this.emit(PlaybackState.Playing);\n    }\n\n    private disconnectSource() {\n        if (this.element) return; // leave connected, we can (and must) re-use it\n        this.source?.disconnect();\n        this.source?.removeEventListener(\"ended\", this.onPlaybackEnd);\n    }\n\n    private makeNewSourceBuffer() {\n        if (this.element && this.source) return; // leave connected, we can (and must) re-use it\n\n        if (this.element) {\n            this.source = this.context.createMediaElementSource(this.element);\n        } else {\n            this.source = this.context.createBufferSource();\n            this.source.buffer = this.audioBuf;\n        }\n\n        this.source.addEventListener(\"ended\", this.onPlaybackEnd);\n        this.source.connect(this.context.destination);\n    }\n\n    public async pause() {\n        await this.context.suspend();\n        this.emit(PlaybackState.Paused);\n    }\n\n    public async stop() {\n        await this.onPlaybackEnd();\n        this.clock.flagStop();\n    }\n\n    public async toggle() {\n        if (this.isPlaying) await this.pause();\n        else await this.play();\n    }\n\n    public async skipTo(timeSeconds: number) {\n        // Dev note: this function talks a lot about clock desyncs. There is a clock running\n        // independently to the audio context and buffer so that accurate human-perceptible\n        // time can be exposed. The PlaybackClock class has more information, but the short\n        // version is that we need to line up the useful time (clip position) with the context\n        // time, and avoid as many deviations as possible as otherwise the user could see the\n        // wrong time, and we stop playback at the wrong time, etc.\n\n        timeSeconds = clamp(timeSeconds, 0, this.clock.durationSeconds);\n\n        // Track playing state so we don't cause seeking to start playing the track.\n        const isPlaying = this.isPlaying;\n\n        if (isPlaying) {\n            // Pause first so we can get an accurate measurement of time\n            await this.context.suspend();\n        }\n\n        // We can't simply tell the context/buffer to jump to a time, so we have to\n        // start a whole new buffer and start it from the new time offset.\n        const now = this.context.currentTime;\n        this.disconnectSource();\n        this.makeNewSourceBuffer();\n\n        // We have to resync the clock because it can get confused about where we're\n        // at in the audio clip.\n        this.clock.syncTo(now, timeSeconds);\n\n        // Always start the source to queue it up. We have to do this now (and pause\n        // quickly if we're not supposed to be playing) as otherwise the clock can desync\n        // when it comes time to the user hitting play. After a couple jumps, the user\n        // will have desynced the clock enough to be about 10-15 seconds off, while this\n        // keeps it as close to perfect as humans can perceive.\n        if (this.element) {\n            this.element.currentTime = timeSeconds;\n        } else {\n            (this.source as AudioBufferSourceNode).start(now, timeSeconds);\n        }\n\n        // Dev note: it's critical that the code gap between `this.source.start()` and\n        // `this.pause()` is as small as possible: we do not want to delay *anything*\n        // as that could cause a clock desync, or a buggy feeling as a single note plays\n        // during seeking.\n\n        if (isPlaying) {\n            // If we were playing before, continue the context so the clock doesn't desync.\n            await this.context.resume();\n        } else {\n            // As mentioned above, we'll have to pause the clip if we weren't supposed to\n            // be playing it just yet. If we didn't have this, the audio clip plays but all\n            // the states will be wrong: clock won't advance, pause state doesn't match the\n            // blaring noise leaving the user's speakers, etc.\n            //\n            // Also as mentioned, if the code gap is small enough then this should be\n            // executed immediately after the start time, leaving no feasible time for the\n            // user's speakers to play any sound.\n            await this.pause();\n        }\n    }\n}\n"],"mappings":"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"}