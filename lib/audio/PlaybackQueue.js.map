{"version":3,"file":"PlaybackQueue.js","names":["PlaybackQueue","constructor","room","Map","Set","loadClocks","RoomViewStore","instance","addRoomListener","roomId","isActive","currentPlaybackId","recentFullPlays","playbackIdOrder","forRoom","cli","MatrixClientPeg","get","getRoom","Error","queues","has","queue","set","persistClocks","localStorage","setItem","JSON","stringify","Array","from","clockStates","entries","val","getItem","parse","unsortedEnqueue","mxEvent","playback","playbacks","getId","on","UPDATE_EVENT","state","onPlaybackStateChange","clockInfo","liveData","onUpdate","clock","onPlaybackClock","newState","wasLastPlaying","PlaybackState","Stopped","skipTo","delete","add","orderClone","arrayFastClone","last","pop","next","logger","warn","PlaybackManager","pauseAllExcept","play","timeline","getLiveTimeline","getEvents","scanForVoiceMessage","nextEv","event","isVoiceMessage","evType","getType","EventType","RoomMessage","Sticker","havePlayback","isRecentlyCompleted","Playing","order","length","lastInstance","currentState","Paused","push","clocks","Decoding"],"sources":["../../src/audio/PlaybackQueue.ts"],"sourcesContent":["/*\nCopyright 2021 - 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { MatrixEvent } from \"matrix-js-sdk/src/models/event\";\nimport { Room } from \"matrix-js-sdk/src/models/room\";\nimport { EventType } from \"matrix-js-sdk/src/@types/event\";\nimport { logger } from \"matrix-js-sdk/src/logger\";\n\nimport { Playback, PlaybackState } from \"./Playback\";\nimport { UPDATE_EVENT } from \"../stores/AsyncStore\";\nimport { MatrixClientPeg } from \"../MatrixClientPeg\";\nimport { arrayFastClone } from \"../utils/arrays\";\nimport { PlaybackManager } from \"./PlaybackManager\";\nimport { isVoiceMessage } from \"../utils/EventUtils\";\nimport { RoomViewStore } from \"../stores/RoomViewStore\";\n\n/**\n * Audio playback queue management for a given room. This keeps track of where the user\n * was at for each playback, what order the playbacks were played in, and triggers subsequent\n * playbacks.\n *\n * Currently this is only intended to be used by voice messages.\n *\n * The primary mechanics are:\n * * Persisted clock state for each playback instance (tied to Event ID).\n * * Limited memory of playback order (see code; not persisted).\n * * Autoplay of next eligible playback instance.\n */\nexport class PlaybackQueue {\n    private static queues = new Map<string, PlaybackQueue>(); // keyed by room ID\n\n    private playbacks = new Map<string, Playback>(); // keyed by event ID\n    private clockStates = new Map<string, number>(); // keyed by event ID\n    private playbackIdOrder: string[] = []; // event IDs, last == current\n    private currentPlaybackId: string; // event ID, broken out from above for ease of use\n    private recentFullPlays = new Set<string>(); // event IDs\n\n    constructor(private room: Room) {\n        this.loadClocks();\n\n        RoomViewStore.instance.addRoomListener(this.room.roomId, (isActive) => {\n            if (!isActive) return;\n\n            // Reset the state of the playbacks before they start mounting and enqueuing updates.\n            // We reset the entirety of the queue, including order, to ensure the user isn't left\n            // confused with what order the messages are playing in.\n            this.currentPlaybackId = null; // this in particular stops autoplay when the room is switched to\n            this.recentFullPlays = new Set<string>();\n            this.playbackIdOrder = [];\n        });\n    }\n\n    public static forRoom(roomId: string): PlaybackQueue {\n        const cli = MatrixClientPeg.get();\n        const room = cli.getRoom(roomId);\n        if (!room) throw new Error(\"Unknown room\");\n        if (PlaybackQueue.queues.has(room.roomId)) {\n            return PlaybackQueue.queues.get(room.roomId);\n        }\n        const queue = new PlaybackQueue(room);\n        PlaybackQueue.queues.set(room.roomId, queue);\n        return queue;\n    }\n\n    private persistClocks() {\n        localStorage.setItem(\n            `mx_voice_message_clocks_${this.room.roomId}`,\n            JSON.stringify(Array.from(this.clockStates.entries())),\n        );\n    }\n\n    private loadClocks() {\n        const val = localStorage.getItem(`mx_voice_message_clocks_${this.room.roomId}`);\n        if (!!val) {\n            this.clockStates = new Map<string, number>(JSON.parse(val));\n        }\n    }\n\n    public unsortedEnqueue(mxEvent: MatrixEvent, playback: Playback) {\n        // We don't ever detach our listeners: we expect the Playback to clean up for us\n        this.playbacks.set(mxEvent.getId(), playback);\n        playback.on(UPDATE_EVENT, (state) => this.onPlaybackStateChange(playback, mxEvent, state));\n        playback.clockInfo.liveData.onUpdate((clock) => this.onPlaybackClock(playback, mxEvent, clock));\n    }\n\n    private onPlaybackStateChange(playback: Playback, mxEvent: MatrixEvent, newState: PlaybackState) {\n        // Remember where the user got to in playback\n        const wasLastPlaying = this.currentPlaybackId === mxEvent.getId();\n        if (newState === PlaybackState.Stopped && this.clockStates.has(mxEvent.getId()) && !wasLastPlaying) {\n            // noinspection JSIgnoredPromiseFromCall\n            playback.skipTo(this.clockStates.get(mxEvent.getId()));\n        } else if (newState === PlaybackState.Stopped) {\n            // Remove the now-useless clock for some space savings\n            this.clockStates.delete(mxEvent.getId());\n\n            if (wasLastPlaying) {\n                this.recentFullPlays.add(this.currentPlaybackId);\n                const orderClone = arrayFastClone(this.playbackIdOrder);\n                const last = orderClone.pop();\n                if (last === this.currentPlaybackId) {\n                    const next = orderClone.pop();\n                    if (next) {\n                        const instance = this.playbacks.get(next);\n                        if (!instance) {\n                            logger.warn(\n                                \"Voice message queue desync: Missing playback for next message: \"\n                                + `Current=${this.currentPlaybackId} Last=${last} Next=${next}`,\n                            );\n                        } else {\n                            this.playbackIdOrder = orderClone;\n                            PlaybackManager.instance.pauseAllExcept(instance);\n\n                            // This should cause a Play event, which will re-populate our playback order\n                            // and update our current playback ID.\n                            // noinspection JSIgnoredPromiseFromCall\n                            instance.play();\n                        }\n                    } else {\n                        // else no explicit next event, so find an event we haven't played that comes next. The live\n                        // timeline is already most recent last, so we can iterate down that.\n                        const timeline = arrayFastClone(this.room.getLiveTimeline().getEvents());\n                        let scanForVoiceMessage = false;\n                        let nextEv: MatrixEvent;\n                        for (const event of timeline) {\n                            if (event.getId() === mxEvent.getId()) {\n                                scanForVoiceMessage = true;\n                                continue;\n                            }\n                            if (!scanForVoiceMessage) continue;\n\n                            if (!isVoiceMessage(event)) {\n                                const evType = event.getType();\n                                if (evType !== EventType.RoomMessage && evType !== EventType.Sticker) {\n                                    continue; // Event can be skipped for automatic playback consideration\n                                }\n                                break; // Stop automatic playback: next useful event is not a voice message\n                            }\n\n                            const havePlayback = this.playbacks.has(event.getId());\n                            const isRecentlyCompleted = this.recentFullPlays.has(event.getId());\n                            if (havePlayback && !isRecentlyCompleted) {\n                                nextEv = event;\n                                break;\n                            }\n                        }\n                        if (!nextEv) {\n                            // if we don't have anywhere to go, reset the recent playback queue so the user\n                            // can start a new chain of playbacks.\n                            this.recentFullPlays = new Set<string>();\n                            this.playbackIdOrder = [];\n                        } else {\n                            this.playbackIdOrder = orderClone;\n\n                            const instance = this.playbacks.get(nextEv.getId());\n                            PlaybackManager.instance.pauseAllExcept(instance);\n\n                            // This should cause a Play event, which will re-populate our playback order\n                            // and update our current playback ID.\n                            // noinspection JSIgnoredPromiseFromCall\n                            instance.play();\n                        }\n                    }\n                } else {\n                    logger.warn(\n                        \"Voice message queue desync: Expected playback stop to be last in order. \"\n                        + `Current=${this.currentPlaybackId} Last=${last} EventID=${mxEvent.getId()}`,\n                    );\n                }\n            }\n        }\n\n        if (newState === PlaybackState.Playing) {\n            const order = this.playbackIdOrder;\n            if (this.currentPlaybackId !== mxEvent.getId() && !!this.currentPlaybackId) {\n                if (order.length === 0 || order[order.length - 1] !== this.currentPlaybackId) {\n                    const lastInstance = this.playbacks.get(this.currentPlaybackId);\n                    if (\n                        lastInstance.currentState === PlaybackState.Playing\n                        || lastInstance.currentState === PlaybackState.Paused\n                    ) {\n                        order.push(this.currentPlaybackId);\n                    }\n                }\n            }\n\n            this.currentPlaybackId = mxEvent.getId();\n            if (order.length === 0 || order[order.length - 1] !== this.currentPlaybackId) {\n                order.push(this.currentPlaybackId);\n            }\n        }\n\n        // Only persist clock information on pause/stop (end) to avoid overwhelming the storage.\n        // This should get triggered from normal voice message component unmount due to the playback\n        // stopping itself for cleanup.\n        if (newState === PlaybackState.Paused || newState === PlaybackState.Stopped) {\n            this.persistClocks();\n        }\n    }\n\n    private onPlaybackClock(playback: Playback, mxEvent: MatrixEvent, clocks: number[]) {\n        if (playback.currentState === PlaybackState.Decoding) return; // ignore pre-ready values\n\n        if (playback.currentState !== PlaybackState.Stopped) {\n            this.clockStates.set(mxEvent.getId(), clocks[0]); // [0] is the current seek position\n        }\n    }\n}\n"],"mappings":";;;;;;;;;;;AAkBA;;AACA;;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AA3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAMA,aAAN,CAAoB;EACmC;EAET;EACA;EACT;EACL;EACU;EAE7CC,WAAW,CAASC,IAAT,EAAqB;IAAA,KAAZA,IAAY,GAAZA,IAAY;IAAA,iDANZ,IAAIC,GAAJ,EAMY;IAAA,mDALV,IAAIA,GAAJ,EAKU;IAAA,uDAJI,EAIJ;IAAA;IAAA,uDAFN,IAAIC,GAAJ,EAEM;IAC5B,KAAKC,UAAL;;IAEAC,4BAAA,CAAcC,QAAd,CAAuBC,eAAvB,CAAuC,KAAKN,IAAL,CAAUO,MAAjD,EAA0DC,QAAD,IAAc;MACnE,IAAI,CAACA,QAAL,EAAe,OADoD,CAGnE;MACA;MACA;;MACA,KAAKC,iBAAL,GAAyB,IAAzB,CANmE,CAMpC;;MAC/B,KAAKC,eAAL,GAAuB,IAAIR,GAAJ,EAAvB;MACA,KAAKS,eAAL,GAAuB,EAAvB;IACH,CATD;EAUH;;EAEoB,OAAPC,OAAO,CAACL,MAAD,EAAgC;IACjD,MAAMM,GAAG,GAAGC,gCAAA,CAAgBC,GAAhB,EAAZ;;IACA,MAAMf,IAAI,GAAGa,GAAG,CAACG,OAAJ,CAAYT,MAAZ,CAAb;IACA,IAAI,CAACP,IAAL,EAAW,MAAM,IAAIiB,KAAJ,CAAU,cAAV,CAAN;;IACX,IAAInB,aAAa,CAACoB,MAAd,CAAqBC,GAArB,CAAyBnB,IAAI,CAACO,MAA9B,CAAJ,EAA2C;MACvC,OAAOT,aAAa,CAACoB,MAAd,CAAqBH,GAArB,CAAyBf,IAAI,CAACO,MAA9B,CAAP;IACH;;IACD,MAAMa,KAAK,GAAG,IAAItB,aAAJ,CAAkBE,IAAlB,CAAd;IACAF,aAAa,CAACoB,MAAd,CAAqBG,GAArB,CAAyBrB,IAAI,CAACO,MAA9B,EAAsCa,KAAtC;IACA,OAAOA,KAAP;EACH;;EAEOE,aAAa,GAAG;IACpBC,YAAY,CAACC,OAAb,CACK,2BAA0B,KAAKxB,IAAL,CAAUO,MAAO,EADhD,EAEIkB,IAAI,CAACC,SAAL,CAAeC,KAAK,CAACC,IAAN,CAAW,KAAKC,WAAL,CAAiBC,OAAjB,EAAX,CAAf,CAFJ;EAIH;;EAEO3B,UAAU,GAAG;IACjB,MAAM4B,GAAG,GAAGR,YAAY,CAACS,OAAb,CAAsB,2BAA0B,KAAKhC,IAAL,CAAUO,MAAO,EAAjE,CAAZ;;IACA,IAAI,CAAC,CAACwB,GAAN,EAAW;MACP,KAAKF,WAAL,GAAmB,IAAI5B,GAAJ,CAAwBwB,IAAI,CAACQ,KAAL,CAAWF,GAAX,CAAxB,CAAnB;IACH;EACJ;;EAEMG,eAAe,CAACC,OAAD,EAAuBC,QAAvB,EAA2C;IAC7D;IACA,KAAKC,SAAL,CAAehB,GAAf,CAAmBc,OAAO,CAACG,KAAR,EAAnB,EAAoCF,QAApC;IACAA,QAAQ,CAACG,EAAT,CAAYC,wBAAZ,EAA2BC,KAAD,IAAW,KAAKC,qBAAL,CAA2BN,QAA3B,EAAqCD,OAArC,EAA8CM,KAA9C,CAArC;IACAL,QAAQ,CAACO,SAAT,CAAmBC,QAAnB,CAA4BC,QAA5B,CAAsCC,KAAD,IAAW,KAAKC,eAAL,CAAqBX,QAArB,EAA+BD,OAA/B,EAAwCW,KAAxC,CAAhD;EACH;;EAEOJ,qBAAqB,CAACN,QAAD,EAAqBD,OAArB,EAA2Ca,QAA3C,EAAoE;IAC7F;IACA,MAAMC,cAAc,GAAG,KAAKxC,iBAAL,KAA2B0B,OAAO,CAACG,KAAR,EAAlD;;IACA,IAAIU,QAAQ,KAAKE,uBAAA,CAAcC,OAA3B,IAAsC,KAAKtB,WAAL,CAAiBV,GAAjB,CAAqBgB,OAAO,CAACG,KAAR,EAArB,CAAtC,IAA+E,CAACW,cAApF,EAAoG;MAChG;MACAb,QAAQ,CAACgB,MAAT,CAAgB,KAAKvB,WAAL,CAAiBd,GAAjB,CAAqBoB,OAAO,CAACG,KAAR,EAArB,CAAhB;IACH,CAHD,MAGO,IAAIU,QAAQ,KAAKE,uBAAA,CAAcC,OAA/B,EAAwC;MAC3C;MACA,KAAKtB,WAAL,CAAiBwB,MAAjB,CAAwBlB,OAAO,CAACG,KAAR,EAAxB;;MAEA,IAAIW,cAAJ,EAAoB;QAChB,KAAKvC,eAAL,CAAqB4C,GAArB,CAAyB,KAAK7C,iBAA9B;QACA,MAAM8C,UAAU,GAAG,IAAAC,sBAAA,EAAe,KAAK7C,eAApB,CAAnB;QACA,MAAM8C,IAAI,GAAGF,UAAU,CAACG,GAAX,EAAb;;QACA,IAAID,IAAI,KAAK,KAAKhD,iBAAlB,EAAqC;UACjC,MAAMkD,IAAI,GAAGJ,UAAU,CAACG,GAAX,EAAb;;UACA,IAAIC,IAAJ,EAAU;YACN,MAAMtD,QAAQ,GAAG,KAAKgC,SAAL,CAAetB,GAAf,CAAmB4C,IAAnB,CAAjB;;YACA,IAAI,CAACtD,QAAL,EAAe;cACXuD,cAAA,CAAOC,IAAP,CACI,oEACG,WAAU,KAAKpD,iBAAkB,SAAQgD,IAAK,SAAQE,IAAK,EAFlE;YAIH,CALD,MAKO;cACH,KAAKhD,eAAL,GAAuB4C,UAAvB;;cACAO,gCAAA,CAAgBzD,QAAhB,CAAyB0D,cAAzB,CAAwC1D,QAAxC,EAFG,CAIH;cACA;cACA;;;cACAA,QAAQ,CAAC2D,IAAT;YACH;UACJ,CAhBD,MAgBO;YACH;YACA;YACA,MAAMC,QAAQ,GAAG,IAAAT,sBAAA,EAAe,KAAKxD,IAAL,CAAUkE,eAAV,GAA4BC,SAA5B,EAAf,CAAjB;YACA,IAAIC,mBAAmB,GAAG,KAA1B;YACA,IAAIC,MAAJ;;YACA,KAAK,MAAMC,KAAX,IAAoBL,QAApB,EAA8B;cAC1B,IAAIK,KAAK,CAAChC,KAAN,OAAkBH,OAAO,CAACG,KAAR,EAAtB,EAAuC;gBACnC8B,mBAAmB,GAAG,IAAtB;gBACA;cACH;;cACD,IAAI,CAACA,mBAAL,EAA0B;;cAE1B,IAAI,CAAC,IAAAG,0BAAA,EAAeD,KAAf,CAAL,EAA4B;gBACxB,MAAME,MAAM,GAAGF,KAAK,CAACG,OAAN,EAAf;;gBACA,IAAID,MAAM,KAAKE,gBAAA,CAAUC,WAArB,IAAoCH,MAAM,KAAKE,gBAAA,CAAUE,OAA7D,EAAsE;kBAClE,SADkE,CACxD;gBACb;;gBACD,MALwB,CAKjB;cACV;;cAED,MAAMC,YAAY,GAAG,KAAKxC,SAAL,CAAelB,GAAf,CAAmBmD,KAAK,CAAChC,KAAN,EAAnB,CAArB;cACA,MAAMwC,mBAAmB,GAAG,KAAKpE,eAAL,CAAqBS,GAArB,CAAyBmD,KAAK,CAAChC,KAAN,EAAzB,CAA5B;;cACA,IAAIuC,YAAY,IAAI,CAACC,mBAArB,EAA0C;gBACtCT,MAAM,GAAGC,KAAT;gBACA;cACH;YACJ;;YACD,IAAI,CAACD,MAAL,EAAa;cACT;cACA;cACA,KAAK3D,eAAL,GAAuB,IAAIR,GAAJ,EAAvB;cACA,KAAKS,eAAL,GAAuB,EAAvB;YACH,CALD,MAKO;cACH,KAAKA,eAAL,GAAuB4C,UAAvB;cAEA,MAAMlD,QAAQ,GAAG,KAAKgC,SAAL,CAAetB,GAAf,CAAmBsD,MAAM,CAAC/B,KAAP,EAAnB,CAAjB;;cACAwB,gCAAA,CAAgBzD,QAAhB,CAAyB0D,cAAzB,CAAwC1D,QAAxC,EAJG,CAMH;cACA;cACA;;;cACAA,QAAQ,CAAC2D,IAAT;YACH;UACJ;QACJ,CA/DD,MA+DO;UACHJ,cAAA,CAAOC,IAAP,CACI,6EACG,WAAU,KAAKpD,iBAAkB,SAAQgD,IAAK,YAAWtB,OAAO,CAACG,KAAR,EAAgB,EAFhF;QAIH;MACJ;IACJ;;IAED,IAAIU,QAAQ,KAAKE,uBAAA,CAAc6B,OAA/B,EAAwC;MACpC,MAAMC,KAAK,GAAG,KAAKrE,eAAnB;;MACA,IAAI,KAAKF,iBAAL,KAA2B0B,OAAO,CAACG,KAAR,EAA3B,IAA8C,CAAC,CAAC,KAAK7B,iBAAzD,EAA4E;QACxE,IAAIuE,KAAK,CAACC,MAAN,KAAiB,CAAjB,IAAsBD,KAAK,CAACA,KAAK,CAACC,MAAN,GAAe,CAAhB,CAAL,KAA4B,KAAKxE,iBAA3D,EAA8E;UAC1E,MAAMyE,YAAY,GAAG,KAAK7C,SAAL,CAAetB,GAAf,CAAmB,KAAKN,iBAAxB,CAArB;;UACA,IACIyE,YAAY,CAACC,YAAb,KAA8BjC,uBAAA,CAAc6B,OAA5C,IACGG,YAAY,CAACC,YAAb,KAA8BjC,uBAAA,CAAckC,MAFnD,EAGE;YACEJ,KAAK,CAACK,IAAN,CAAW,KAAK5E,iBAAhB;UACH;QACJ;MACJ;;MAED,KAAKA,iBAAL,GAAyB0B,OAAO,CAACG,KAAR,EAAzB;;MACA,IAAI0C,KAAK,CAACC,MAAN,KAAiB,CAAjB,IAAsBD,KAAK,CAACA,KAAK,CAACC,MAAN,GAAe,CAAhB,CAAL,KAA4B,KAAKxE,iBAA3D,EAA8E;QAC1EuE,KAAK,CAACK,IAAN,CAAW,KAAK5E,iBAAhB;MACH;IACJ,CAxG4F,CA0G7F;IACA;IACA;;;IACA,IAAIuC,QAAQ,KAAKE,uBAAA,CAAckC,MAA3B,IAAqCpC,QAAQ,KAAKE,uBAAA,CAAcC,OAApE,EAA6E;MACzE,KAAK7B,aAAL;IACH;EACJ;;EAEOyB,eAAe,CAACX,QAAD,EAAqBD,OAArB,EAA2CmD,MAA3C,EAA6D;IAChF,IAAIlD,QAAQ,CAAC+C,YAAT,KAA0BjC,uBAAA,CAAcqC,QAA5C,EAAsD,OAD0B,CAClB;;IAE9D,IAAInD,QAAQ,CAAC+C,YAAT,KAA0BjC,uBAAA,CAAcC,OAA5C,EAAqD;MACjD,KAAKtB,WAAL,CAAiBR,GAAjB,CAAqBc,OAAO,CAACG,KAAR,EAArB,EAAsCgD,MAAM,CAAC,CAAD,CAA5C,EADiD,CACC;IACrD;EACJ;;AAjLsB;;;8BAAdxF,a,YACe,IAAIG,GAAJ,E"}