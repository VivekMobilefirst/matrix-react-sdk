{"version":3,"file":"VoiceRecording.js","names":["CHANNELS","SAMPLE_RATE","BITRATE","TARGET_MAX_LENGTH","TARGET_WARN_TIME_LEFT","RECORDING_PLAYBACK_SAMPLES","RecordingState","VoiceRecording","EventEmitter","constructor","client","Uint8Array","FixedRollingArray","ev","processAudioUpdate","playbackTime","timeSeconds","recording","observable","update","waveform","liveWaveform","value","map","v","clamp","recorderSeconds","recorder","encodedSamplePosition","secondsLeft","stop","Singleflight","for","do","emit","EndingSoon","Void","contentType","contentLength","buffer","length","durationSeconds","Error","recorderContext","currentTime","isRecording","event","args","UPDATE_EVENT","makeRecorder","recorderStream","navigator","mediaDevices","getUserMedia","audio","channelCount","noiseSuppression","deviceId","MediaDeviceHandler","getAudioInput","createAudioContext","recorderSource","createMediaStreamSource","audioWorklet","addModule","mxRecorderWorkletPath","recorderWorklet","AudioWorkletNode","WORKLET_NAME","connect","destination","port","onmessage","data","PayloadEvent","Timekeep","AmplitudeMark","amplitudes","push","pushValue","recorderProcessor","createScriptProcessor","addEventListener","onAudioProcess","Recorder","encoderPath","encoderSampleRate","encoderApplication","streamPages","encoderFrameSize","numberOfChannels","sourceNode","encoderBitRate","encoderComplexity","resampleQuality","ondataavailable","a","buf","newBuf","set","e","logger","error","DOMException","name","code","message","getTracks","forEach","t","disconnect","close","audioBuffer","slice","liveData","isSupported","isRecordingSupported","hasRecording","start","lastUpload","SimpleObservable","Started","removeEventListener","Ended","getPlayback","playback","Playback","destroy","removeAllListeners","forgetAllFor","upload","inRoomId","Uploading","url","mxc","file","encrypted","uploadFile","Blob","type","Uploaded"],"sources":["../../src/audio/VoiceRecording.ts"],"sourcesContent":["/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport * as Recorder from 'opus-recorder';\nimport encoderPath from 'opus-recorder/dist/encoderWorker.min.js';\nimport { MatrixClient } from \"matrix-js-sdk/src/client\";\nimport { SimpleObservable } from \"matrix-widget-api\";\nimport EventEmitter from \"events\";\nimport { IEncryptedFile } from \"matrix-js-sdk/src/@types/event\";\nimport { logger } from \"matrix-js-sdk/src/logger\";\n\nimport MediaDeviceHandler from \"../MediaDeviceHandler\";\nimport { IDestroyable } from \"../utils/IDestroyable\";\nimport { Singleflight } from \"../utils/Singleflight\";\nimport { PayloadEvent, WORKLET_NAME } from \"./consts\";\nimport { UPDATE_EVENT } from \"../stores/AsyncStore\";\nimport { Playback } from \"./Playback\";\nimport { createAudioContext } from \"./compat\";\nimport { uploadFile } from \"../ContentMessages\";\nimport { FixedRollingArray } from \"../utils/FixedRollingArray\";\nimport { clamp } from \"../utils/numbers\";\nimport mxRecorderWorkletPath from \"./RecorderWorklet\";\n\nconst CHANNELS = 1; // stereo isn't important\nexport const SAMPLE_RATE = 48000; // 48khz is what WebRTC uses. 12khz is where we lose quality.\nconst BITRATE = 24000; // 24kbps is pretty high quality for our use case in opus.\nconst TARGET_MAX_LENGTH = 900; // 15 minutes in seconds. Somewhat arbitrary, though longer == larger files.\nconst TARGET_WARN_TIME_LEFT = 10; // 10 seconds, also somewhat arbitrary.\n\nexport const RECORDING_PLAYBACK_SAMPLES = 44;\n\nexport interface IRecordingUpdate {\n    waveform: number[]; // floating points between 0 (low) and 1 (high).\n    timeSeconds: number; // float\n}\n\nexport enum RecordingState {\n    Started = \"started\",\n    EndingSoon = \"ending_soon\", // emits an object with a single numerical value: secondsLeft\n    Ended = \"ended\",\n    Uploading = \"uploading\",\n    Uploaded = \"uploaded\",\n}\n\nexport interface IUpload {\n    mxc?: string; // for unencrypted uploads\n    encrypted?: IEncryptedFile;\n}\n\nexport class VoiceRecording extends EventEmitter implements IDestroyable {\n    private recorder: Recorder;\n    private recorderContext: AudioContext;\n    private recorderSource: MediaStreamAudioSourceNode;\n    private recorderStream: MediaStream;\n    private recorderWorklet: AudioWorkletNode;\n    private recorderProcessor: ScriptProcessorNode;\n    private buffer = new Uint8Array(0); // use this.audioBuffer to access\n    private lastUpload: IUpload;\n    private recording = false;\n    private observable: SimpleObservable<IRecordingUpdate>;\n    private amplitudes: number[] = []; // at each second mark, generated\n    private playback: Playback;\n    private liveWaveform = new FixedRollingArray(RECORDING_PLAYBACK_SAMPLES, 0);\n\n    public constructor(private client: MatrixClient) {\n        super();\n    }\n\n    public get contentType(): string {\n        return \"audio/ogg\";\n    }\n\n    public get contentLength(): number {\n        return this.buffer.length;\n    }\n\n    public get durationSeconds(): number {\n        if (!this.recorder) throw new Error(\"Duration not available without a recording\");\n        return this.recorderContext.currentTime;\n    }\n\n    public get isRecording(): boolean {\n        return this.recording;\n    }\n\n    public emit(event: string, ...args: any[]): boolean {\n        super.emit(event, ...args);\n        super.emit(UPDATE_EVENT, event, ...args);\n        return true; // we don't ever care if the event had listeners, so just return \"yes\"\n    }\n\n    private async makeRecorder() {\n        try {\n            this.recorderStream = await navigator.mediaDevices.getUserMedia({\n                audio: {\n                    channelCount: CHANNELS,\n                    noiseSuppression: true, // browsers ignore constraints they can't honour\n                    deviceId: MediaDeviceHandler.getAudioInput(),\n                },\n            });\n            this.recorderContext = createAudioContext({\n                // latencyHint: \"interactive\", // we don't want a latency hint (this causes data smoothing)\n            });\n            this.recorderSource = this.recorderContext.createMediaStreamSource(this.recorderStream);\n\n            // Connect our inputs and outputs\n            if (this.recorderContext.audioWorklet) {\n                // Set up our worklet. We use this for timing information and waveform analysis: the\n                // web audio API prefers this be done async to avoid holding the main thread with math.\n                await this.recorderContext.audioWorklet.addModule(mxRecorderWorkletPath);\n                this.recorderWorklet = new AudioWorkletNode(this.recorderContext, WORKLET_NAME);\n                this.recorderSource.connect(this.recorderWorklet);\n                this.recorderWorklet.connect(this.recorderContext.destination);\n\n                // Dev note: we can't use `addEventListener` for some reason. It just doesn't work.\n                this.recorderWorklet.port.onmessage = (ev) => {\n                    switch (ev.data['ev']) {\n                        case PayloadEvent.Timekeep:\n                            this.processAudioUpdate(ev.data['timeSeconds']);\n                            break;\n                        case PayloadEvent.AmplitudeMark:\n                            // Sanity check to make sure we're adding about one sample per second\n                            if (ev.data['forIndex'] === this.amplitudes.length) {\n                                this.amplitudes.push(ev.data['amplitude']);\n                                this.liveWaveform.pushValue(ev.data['amplitude']);\n                            }\n                            break;\n                    }\n                };\n            } else {\n                // Safari fallback: use a processor node instead, buffered to 1024 bytes of data\n                // like the worklet is.\n                this.recorderProcessor = this.recorderContext.createScriptProcessor(1024, CHANNELS, CHANNELS);\n                this.recorderSource.connect(this.recorderProcessor);\n                this.recorderProcessor.connect(this.recorderContext.destination);\n                this.recorderProcessor.addEventListener(\"audioprocess\", this.onAudioProcess);\n            }\n\n            this.recorder = new Recorder({\n                encoderPath, // magic from webpack\n                encoderSampleRate: SAMPLE_RATE,\n                encoderApplication: 2048, // voice (default is \"audio\")\n                streamPages: true, // this speeds up the encoding process by using CPU over time\n                encoderFrameSize: 20, // ms, arbitrary frame size we send to the encoder\n                numberOfChannels: CHANNELS,\n                sourceNode: this.recorderSource,\n                encoderBitRate: BITRATE,\n\n                // We use low values for the following to ease CPU usage - the resulting waveform\n                // is indistinguishable for a voice message. Note that the underlying library will\n                // pick defaults which prefer the highest possible quality, CPU be damned.\n                encoderComplexity: 3, // 0-10, 10 is slow and high quality.\n                resampleQuality: 3, // 0-10, 10 is slow and high quality\n            });\n            this.recorder.ondataavailable = (a: ArrayBuffer) => {\n                const buf = new Uint8Array(a);\n                const newBuf = new Uint8Array(this.buffer.length + buf.length);\n                newBuf.set(this.buffer, 0);\n                newBuf.set(buf, this.buffer.length);\n                this.buffer = newBuf;\n            };\n        } catch (e) {\n            logger.error(\"Error starting recording: \", e);\n            if (e instanceof DOMException) { // Unhelpful DOMExceptions are common - parse them sanely\n                logger.error(`${e.name} (${e.code}): ${e.message}`);\n            }\n\n            // Clean up as best as possible\n            if (this.recorderStream) this.recorderStream.getTracks().forEach(t => t.stop());\n            if (this.recorderSource) this.recorderSource.disconnect();\n            if (this.recorder) this.recorder.close();\n            if (this.recorderContext) {\n                // noinspection ES6MissingAwait - not important that we wait\n                this.recorderContext.close();\n            }\n\n            throw e; // rethrow so upstream can handle it\n        }\n    }\n\n    private get audioBuffer(): Uint8Array {\n        // We need a clone of the buffer to avoid accidentally changing the position\n        // on the real thing.\n        return this.buffer.slice(0);\n    }\n\n    public get liveData(): SimpleObservable<IRecordingUpdate> {\n        if (!this.recording) throw new Error(\"No observable when not recording\");\n        return this.observable;\n    }\n\n    public get isSupported(): boolean {\n        return !!Recorder.isRecordingSupported();\n    }\n\n    public get hasRecording(): boolean {\n        return this.buffer.length > 0;\n    }\n\n    private onAudioProcess = (ev: AudioProcessingEvent) => {\n        this.processAudioUpdate(ev.playbackTime);\n\n        // We skip the functionality of the worklet regarding waveform calculations: we\n        // should get that information pretty quick during the playback info.\n    };\n\n    private processAudioUpdate = (timeSeconds: number) => {\n        if (!this.recording) return;\n\n        this.observable.update({\n            waveform: this.liveWaveform.value.map(v => clamp(v, 0, 1)),\n            timeSeconds: timeSeconds,\n        });\n\n        // Now that we've updated the data/waveform, let's do a time check. We don't want to\n        // go horribly over the limit. We also emit a warning state if needed.\n        //\n        // We use the recorder's perspective of time to make sure we don't cut off the last\n        // frame of audio, otherwise we end up with a 14:59 clip (899.68 seconds). This extra\n        // safety can allow us to overshoot the target a bit, but at least when we say 15min\n        // maximum we actually mean it.\n        //\n        // In testing, recorder time and worker time lag by about 400ms, which is roughly the\n        // time needed to encode a sample/frame.\n        //\n        // Ref for recorderSeconds: https://github.com/chris-rudmin/opus-recorder#instance-fields\n        const recorderSeconds = this.recorder.encodedSamplePosition / 48000;\n        const secondsLeft = TARGET_MAX_LENGTH - recorderSeconds;\n        if (secondsLeft < 0) { // go over to make sure we definitely capture that last frame\n            // noinspection JSIgnoredPromiseFromCall - we aren't concerned with it overlapping\n            this.stop();\n        } else if (secondsLeft <= TARGET_WARN_TIME_LEFT) {\n            Singleflight.for(this, \"ending_soon\").do(() => {\n                this.emit(RecordingState.EndingSoon, { secondsLeft });\n                return Singleflight.Void;\n            });\n        }\n    };\n\n    public async start(): Promise<void> {\n        if (this.lastUpload || this.hasRecording) {\n            throw new Error(\"Recording already prepared\");\n        }\n        if (this.recording) {\n            throw new Error(\"Recording already in progress\");\n        }\n        if (this.observable) {\n            this.observable.close();\n        }\n        this.observable = new SimpleObservable<IRecordingUpdate>();\n        await this.makeRecorder();\n        await this.recorder.start();\n        this.recording = true;\n        this.emit(RecordingState.Started);\n    }\n\n    public async stop(): Promise<Uint8Array> {\n        return Singleflight.for(this, \"stop\").do(async () => {\n            if (!this.recording) {\n                throw new Error(\"No recording to stop\");\n            }\n\n            // Disconnect the source early to start shutting down resources\n            await this.recorder.stop(); // stop first to flush the last frame\n            this.recorderSource.disconnect();\n            if (this.recorderWorklet) this.recorderWorklet.disconnect();\n            if (this.recorderProcessor) {\n                this.recorderProcessor.disconnect();\n                this.recorderProcessor.removeEventListener(\"audioprocess\", this.onAudioProcess);\n            }\n\n            // close the context after the recorder so the recorder doesn't try to\n            // connect anything to the context (this would generate a warning)\n            await this.recorderContext.close();\n\n            // Now stop all the media tracks so we can release them back to the user/OS\n            this.recorderStream.getTracks().forEach(t => t.stop());\n\n            // Finally do our post-processing and clean up\n            this.recording = false;\n            await this.recorder.close();\n            this.emit(RecordingState.Ended);\n\n            return this.audioBuffer;\n        });\n    }\n\n    /**\n     * Gets a playback instance for this voice recording. Note that the playback will not\n     * have been prepared fully, meaning the `prepare()` function needs to be called on it.\n     *\n     * The same playback instance is returned each time.\n     *\n     * @returns {Playback} The playback instance.\n     */\n    public getPlayback(): Playback {\n        this.playback = Singleflight.for(this, \"playback\").do(() => {\n            return new Playback(this.audioBuffer.buffer, this.amplitudes); // cast to ArrayBuffer proper;\n        });\n        return this.playback;\n    }\n\n    public destroy() {\n        // noinspection JSIgnoredPromiseFromCall - not concerned about stop() being called async here\n        this.stop();\n        this.removeAllListeners();\n        Singleflight.forgetAllFor(this);\n        // noinspection JSIgnoredPromiseFromCall - not concerned about being called async here\n        this.playback?.destroy();\n        this.observable.close();\n    }\n\n    public async upload(inRoomId: string): Promise<IUpload> {\n        if (!this.hasRecording) {\n            throw new Error(\"No recording available to upload\");\n        }\n\n        if (this.lastUpload) return this.lastUpload;\n\n        try {\n            this.emit(RecordingState.Uploading);\n            const { url: mxc, file: encrypted } = await uploadFile(this.client, inRoomId, new Blob([this.audioBuffer], {\n                type: this.contentType,\n            }));\n            this.lastUpload = { mxc, encrypted };\n            this.emit(RecordingState.Uploaded);\n        } catch (e) {\n            this.emit(RecordingState.Ended);\n            throw e;\n        }\n        return this.lastUpload;\n    }\n}\n"],"mappings":"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"}