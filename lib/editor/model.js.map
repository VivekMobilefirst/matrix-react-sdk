{"version":3,"file":"model.js","names":["EditorModel","constructor","parts","partCreator","updateCallback","replaceParts","close","pos","_parts","splice","autoCompletePartIdx","autoCompletePartCount","length","lastPart","lastPartIndex","DocumentPosition","text","_autoComplete","_partCreator","transformCallback","setTransformCallback","setUpdateCallback","isEmpty","reduce","len","part","clone","clonedParts","map","p","deserializePart","serialize","insertPart","index","activePartIdx","removePart","replacePart","autoComplete","getPositionAtEnd","serializeParts","diff","newValue","inputType","caret","previousValue","diffDeletion","diffAtCaret","offset","reset","serializedParts","insert","position","insertIndex","splitAt","newTextLength","i","update","positionForOffset","at","atNodeEnd","removedOffsetDecrease","removed","removeText","addedLen","added","addText","mergeAdjacentParts","caretOffset","newPosition","canOpenAutoComplete","acPromise","setActivePart","transformAddedLen","getTransformAddedLen","result","Number","isFinite","ac","createAutoComplete","onAutoComplete","onPartUpdate","Promise","resolve","prevPart","isMerged","merge","amount","Math","min","canEdit","replaceWith","remove","createDefaultPart","secondPart","split","str","addLen","validateAndInsert","splitPart","newPart","createPartForInput","oldStr","appendUntilRejected","console","error","totalOffset","atPartEnd","currentOffset","findIndex","partLen","startRange","positionA","positionB","Range","replaceRange","startPosition","endPosition","endOffset","asOffset","newStartPartIndex","asPosition","newEndPartIndex","insertIdx","transform","callback"],"sources":["../../src/editor/model.ts"],"sourcesContent":["/*\nCopyright 2019 New Vector Ltd\nCopyright 2019 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { diffAtCaret, diffDeletion, IDiff } from \"./diff\";\nimport DocumentPosition, { IPosition } from \"./position\";\nimport Range from \"./range\";\nimport { SerializedPart, Part, PartCreator } from \"./parts\";\nimport AutocompleteWrapperModel, { ICallback } from \"./autocomplete\";\nimport DocumentOffset from \"./offset\";\nimport { Caret } from \"./caret\";\n\n/**\n * @callback ModelCallback\n * @param {DocumentPosition?} caretPosition the position where the caret should be position\n * @param {string?} inputType the inputType of the DOM input event\n * @param {object?} diff an object with `removed` and `added` strings\n */\n\n/**\n * @callback TransformCallback\n * @param {DocumentPosition?} caretPosition the position where the caret should be position\n * @param {string?} inputType the inputType of the DOM input event\n * @param {object?} diff an object with `removed` and `added` strings\n * @return {Number?} addedLen how many characters were added/removed (-) before the caret during the transformation step.\n *    This is used to adjust the caret position.\n */\n\n/**\n * @callback ManualTransformCallback\n * @return the caret position\n */\n\ntype TransformCallback = (caretPosition: DocumentPosition, inputType: string, diff: IDiff) => number | void;\ntype UpdateCallback = (caret: Caret, inputType?: string, diff?: IDiff) => void;\ntype ManualTransformCallback = () => Caret;\n\nexport default class EditorModel {\n    private _parts: Part[];\n    private readonly _partCreator: PartCreator;\n    private activePartIdx: number = null;\n    private _autoComplete: AutocompleteWrapperModel = null;\n    private autoCompletePartIdx: number = null;\n    private autoCompletePartCount = 0;\n    private transformCallback: TransformCallback = null;\n\n    constructor(parts: Part[], partCreator: PartCreator, private updateCallback: UpdateCallback = null) {\n        this._parts = parts;\n        this._partCreator = partCreator;\n        this.transformCallback = null;\n    }\n\n    /**\n     * Set a callback for the transformation step.\n     * While processing an update, right before calling the update callback,\n     * a transform callback can be called, which serves to do modifications\n     * on the model that can span multiple parts. Also see `startRange()`.\n     * @param {TransformCallback} transformCallback\n     */\n    public setTransformCallback(transformCallback: TransformCallback): void {\n        this.transformCallback = transformCallback;\n    }\n\n    /**\n     * Set a callback for rerendering the model after it has been updated.\n     * @param {ModelCallback} updateCallback\n     */\n    public setUpdateCallback(updateCallback: UpdateCallback): void {\n        this.updateCallback = updateCallback;\n    }\n\n    public get partCreator(): PartCreator {\n        return this._partCreator;\n    }\n\n    public get isEmpty(): boolean {\n        return this._parts.reduce((len, part) => len + part.text.length, 0) === 0;\n    }\n\n    public clone(): EditorModel {\n        const clonedParts = this.parts.map(p => this.partCreator.deserializePart(p.serialize()));\n        return new EditorModel(clonedParts, this._partCreator, this.updateCallback);\n    }\n\n    private insertPart(index: number, part: Part): void {\n        this._parts.splice(index, 0, part);\n        if (this.activePartIdx >= index) {\n            ++this.activePartIdx;\n        }\n        if (this.autoCompletePartIdx >= index) {\n            ++this.autoCompletePartIdx;\n        }\n    }\n\n    private removePart(index: number): void {\n        this._parts.splice(index, 1);\n        if (index === this.activePartIdx) {\n            this.activePartIdx = null;\n        } else if (this.activePartIdx > index) {\n            --this.activePartIdx;\n        }\n        if (index === this.autoCompletePartIdx) {\n            this.autoCompletePartIdx = null;\n        } else if (this.autoCompletePartIdx > index) {\n            --this.autoCompletePartIdx;\n        }\n    }\n\n    private replacePart(index: number, part: Part): void {\n        this._parts.splice(index, 1, part);\n    }\n\n    public get parts(): Part[] {\n        return this._parts;\n    }\n\n    public get autoComplete(): AutocompleteWrapperModel {\n        if (this.activePartIdx === this.autoCompletePartIdx) {\n            return this._autoComplete;\n        }\n        return null;\n    }\n\n    public getPositionAtEnd(): DocumentPosition {\n        if (this._parts.length) {\n            const index = this._parts.length - 1;\n            const part = this._parts[index];\n            return new DocumentPosition(index, part.text.length);\n        } else {\n            // part index -1, as there are no parts to point at\n            return new DocumentPosition(-1, 0);\n        }\n    }\n\n    public serializeParts(): SerializedPart[] {\n        return this._parts.map(p => p.serialize());\n    }\n\n    private diff(newValue: string, inputType: string, caret: DocumentOffset): IDiff {\n        const previousValue = this.parts.reduce((text, p) => text + p.text, \"\");\n        // can't use caret position with drag and drop\n        if (inputType === \"deleteByDrag\") {\n            return diffDeletion(previousValue, newValue);\n        } else {\n            return diffAtCaret(previousValue, newValue, caret.offset);\n        }\n    }\n\n    public reset(serializedParts: SerializedPart[], caret?: Caret, inputType?: string): void {\n        this._parts = serializedParts.map(p => this._partCreator.deserializePart(p));\n        if (!caret) {\n            caret = this.getPositionAtEnd();\n        }\n        // close auto complete if open\n        // this would happen when clearing the composer after sending\n        // a message with the autocomplete still open\n        if (this._autoComplete) {\n            this._autoComplete = null;\n            this.autoCompletePartIdx = null;\n        }\n        this.updateCallback(caret, inputType);\n    }\n\n    /**\n     * Inserts the given parts at the given position.\n     * Should be run inside a `model.transform()` callback.\n     * @param {Part[]} parts the parts to replace the range with\n     * @param {DocumentPosition} position the position to start inserting at\n     * @return {Number} the amount of characters added\n     */\n    public insert(parts: Part[], position: IPosition): number {\n        const insertIndex = this.splitAt(position);\n        let newTextLength = 0;\n        for (let i = 0; i < parts.length; ++i) {\n            const part = parts[i];\n            newTextLength += part.text.length;\n            this.insertPart(insertIndex + i, part);\n        }\n        return newTextLength;\n    }\n\n    public update(newValue: string, inputType: string, caret: DocumentOffset): Promise<void> {\n        const diff = this.diff(newValue, inputType, caret);\n        const position = this.positionForOffset(diff.at, caret.atNodeEnd);\n        let removedOffsetDecrease = 0;\n        if (diff.removed) {\n            removedOffsetDecrease = this.removeText(position, diff.removed.length);\n        }\n        let addedLen = 0;\n        if (diff.added) {\n            addedLen = this.addText(position, diff.added, inputType);\n        }\n        this.mergeAdjacentParts();\n        const caretOffset = diff.at - removedOffsetDecrease + addedLen;\n        let newPosition = this.positionForOffset(caretOffset, true);\n        const canOpenAutoComplete = inputType !== \"insertFromPaste\" && inputType !== \"insertFromDrop\";\n        const acPromise = this.setActivePart(newPosition, canOpenAutoComplete);\n        if (this.transformCallback) {\n            const transformAddedLen = this.getTransformAddedLen(newPosition, inputType, diff);\n            newPosition = this.positionForOffset(caretOffset + transformAddedLen, true);\n        }\n        this.updateCallback(newPosition, inputType, diff);\n        return acPromise;\n    }\n\n    private getTransformAddedLen(newPosition: DocumentPosition, inputType: string, diff: IDiff): number {\n        const result = this.transformCallback(newPosition, inputType, diff);\n        return Number.isFinite(result) ? result as number : 0;\n    }\n\n    private setActivePart(pos: DocumentPosition, canOpenAutoComplete: boolean): Promise<void> {\n        const { index } = pos;\n        const part = this._parts[index];\n        if (part) {\n            if (index !== this.activePartIdx) {\n                this.activePartIdx = index;\n                if (canOpenAutoComplete && this.activePartIdx !== this.autoCompletePartIdx) {\n                    // else try to create one\n                    const ac = part.createAutoComplete(this.onAutoComplete);\n                    if (ac) {\n                        // make sure that react picks up the difference between both acs\n                        this._autoComplete = ac;\n                        this.autoCompletePartIdx = index;\n                        this.autoCompletePartCount = 1;\n                    }\n                }\n            }\n            // not autoComplete, only there if active part is autocomplete part\n            if (this.autoComplete) {\n                return this.autoComplete.onPartUpdate(part, pos);\n            }\n        } else {\n            this.activePartIdx = null;\n            this._autoComplete = null;\n            this.autoCompletePartIdx = null;\n            this.autoCompletePartCount = 0;\n        }\n        return Promise.resolve();\n    }\n\n    private onAutoComplete = ({ replaceParts, close }: ICallback): void => {\n        let pos;\n        if (replaceParts) {\n            this._parts.splice(this.autoCompletePartIdx, this.autoCompletePartCount, ...replaceParts);\n            this.autoCompletePartCount = replaceParts.length;\n            const lastPart = replaceParts[replaceParts.length - 1];\n            const lastPartIndex = this.autoCompletePartIdx + replaceParts.length - 1;\n            pos = new DocumentPosition(lastPartIndex, lastPart.text.length);\n        }\n        if (close) {\n            this._autoComplete = null;\n            this.autoCompletePartIdx = null;\n            this.autoCompletePartCount = 0;\n        }\n        // rerender even if editor contents didn't change\n        // to make sure the MessageEditor checks\n        // model.autoComplete being empty and closes it\n        this.updateCallback(pos);\n    };\n\n    private mergeAdjacentParts(): void {\n        let prevPart;\n        for (let i = 0; i < this._parts.length; ++i) {\n            let part = this._parts[i];\n            const isEmpty = !part.text.length;\n            const isMerged = !isEmpty && prevPart && prevPart.merge(part);\n            if (isEmpty || isMerged) {\n                // remove empty or merged part\n                part = prevPart;\n                this.removePart(i);\n                //repeat this index, as it's removed now\n                --i;\n            }\n            prevPart = part;\n        }\n    }\n\n    /**\n     * removes `len` amount of characters at `pos`.\n     * @param {Object} pos\n     * @param {Number} len\n     * @return {Number} how many characters before pos were also removed,\n     * usually because of non-editable parts that can only be removed in their entirety.\n     */\n    public removeText(pos: IPosition, len: number): number {\n        let { index, offset } = pos;\n        let removedOffsetDecrease = 0;\n        while (len > 0) {\n            // part might be undefined here\n            let part = this._parts[index];\n            const amount = Math.min(len, part.text.length - offset);\n            // don't allow 0 amount deletions\n            if (amount) {\n                if (part.canEdit) {\n                    const replaceWith = part.remove(offset, amount);\n                    if (typeof replaceWith === \"string\") {\n                        this.replacePart(index, this._partCreator.createDefaultPart(replaceWith));\n                    }\n                    part = this._parts[index];\n                    // remove empty part\n                    if (!part.text.length) {\n                        this.removePart(index);\n                    } else {\n                        index += 1;\n                    }\n                } else {\n                    removedOffsetDecrease += offset;\n                    this.removePart(index);\n                }\n            } else {\n                index += 1;\n            }\n            len -= amount;\n            offset = 0;\n        }\n        return removedOffsetDecrease;\n    }\n\n    // return part index where insertion will insert between at offset\n    private splitAt(pos: IPosition): number {\n        if (pos.index === -1) {\n            return 0;\n        }\n        if (pos.offset === 0) {\n            return pos.index;\n        }\n        const part = this._parts[pos.index];\n        if (pos.offset >= part.text.length) {\n            return pos.index + 1;\n        }\n\n        const secondPart = part.split(pos.offset);\n        this.insertPart(pos.index + 1, secondPart);\n        return pos.index + 1;\n    }\n\n    /**\n     * inserts `str` into the model at `pos`.\n     * @param {Object} pos\n     * @param {string} str\n     * @param {string} inputType the source of the input, see html InputEvent.inputType\n     * @return {Number} how far from position (in characters) the insertion ended.\n     * This can be more than the length of `str` when crossing non-editable parts, which are skipped.\n     */\n    private addText(pos: IPosition, str: string, inputType: string): number {\n        let { index } = pos;\n        const { offset } = pos;\n        let addLen = str.length;\n        const part = this._parts[index];\n        if (part) {\n            if (part.canEdit) {\n                if (part.validateAndInsert(offset, str, inputType)) {\n                    str = null;\n                } else {\n                    const splitPart = part.split(offset);\n                    index += 1;\n                    this.insertPart(index, splitPart);\n                }\n            } else if (offset !== 0) {\n                // not-editable part, caret is not at start,\n                // so insert str after this part\n                addLen += part.text.length - offset;\n                index += 1;\n            }\n        } else if (index < 0) {\n            // if position was not found (index: -1, as happens for empty editor)\n            // reset it to insert as first part\n            index = 0;\n        }\n        while (str) {\n            const newPart = this._partCreator.createPartForInput(str, index, inputType);\n            const oldStr = str;\n            str = newPart.appendUntilRejected(str, inputType);\n            if (str === oldStr) {\n                // nothing changed, break out of this infinite loop and log an error\n                console.error(`Failed to update model for input (str ${str}) (type ${inputType})`);\n                break;\n            }\n            this.insertPart(index, newPart);\n            index += 1;\n        }\n        return addLen;\n    }\n\n    public positionForOffset(totalOffset: number, atPartEnd = false): DocumentPosition {\n        let currentOffset = 0;\n        const index = this._parts.findIndex(part => {\n            const partLen = part.text.length;\n            if (\n                (atPartEnd && (currentOffset + partLen) >= totalOffset) ||\n                (!atPartEnd && (currentOffset + partLen) > totalOffset)\n            ) {\n                return true;\n            }\n            currentOffset += partLen;\n            return false;\n        });\n        if (index === -1) {\n            return this.getPositionAtEnd();\n        } else {\n            return new DocumentPosition(index, totalOffset - currentOffset);\n        }\n    }\n\n    /**\n     * Starts a range, which can span across multiple parts, to find and replace text.\n     * @param {DocumentPosition} positionA a boundary of the range\n     * @param {DocumentPosition?} positionB the other boundary of the range, optional\n     * @return {Range}\n     */\n    public startRange(positionA: DocumentPosition, positionB = positionA): Range {\n        return new Range(this, positionA, positionB);\n    }\n\n    public replaceRange(startPosition: DocumentPosition, endPosition: DocumentPosition, parts: Part[]): void {\n        // convert end position to offset, so it is independent of how the document is split into parts\n        // which we'll change when splitting up at the start position\n        const endOffset = endPosition.asOffset(this);\n        const newStartPartIndex = this.splitAt(startPosition);\n        // convert it back to position once split at start\n        endPosition = endOffset.asPosition(this);\n        const newEndPartIndex = this.splitAt(endPosition);\n        for (let i = newEndPartIndex - 1; i >= newStartPartIndex; --i) {\n            this.removePart(i);\n        }\n        let insertIdx = newStartPartIndex;\n        for (const part of parts) {\n            this.insertPart(insertIdx, part);\n            insertIdx += 1;\n        }\n        this.mergeAdjacentParts();\n    }\n\n    /**\n     * Performs a transformation not part of an update cycle.\n     * Modifying the model should only happen inside a transform call if not part of an update call.\n     * @param {ManualTransformCallback} callback to run the transformations in\n     * @return {Promise} a promise when auto-complete (if applicable) is done updating\n     */\n    public transform(callback: ManualTransformCallback): Promise<void> {\n        const pos = callback();\n        let acPromise: Promise<void> = null;\n        if (!(pos instanceof Range)) {\n            acPromise = this.setActivePart(pos, true);\n        } else {\n            acPromise = Promise.resolve();\n        }\n        this.updateCallback(pos);\n        return acPromise;\n    }\n}\n"],"mappings":";;;;;;;;;;;AAiBA;;AACA;;AACA;;AAnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAmCe,MAAMA,WAAN,CAAkB;EAS7BC,WAAW,CAACC,KAAD,EAAgBC,WAAhB,EAAyF;IAAA,IAAvCC,cAAuC,uEAAN,IAAM;IAAA,KAAvCA,cAAuC,GAAvCA,cAAuC;IAAA;IAAA;IAAA,qDANpE,IAMoE;IAAA,qDALlD,IAKkD;IAAA,2DAJ9D,IAI8D;IAAA,6DAHpE,CAGoE;IAAA,yDAFrD,IAEqD;IAAA,sDAkM3E,QAA8C;MAAA,IAA7C;QAAEC,YAAF;QAAgBC;MAAhB,CAA6C;MACnE,IAAIC,GAAJ;;MACA,IAAIF,YAAJ,EAAkB;QACd,KAAKG,MAAL,CAAYC,MAAZ,CAAmB,KAAKC,mBAAxB,EAA6C,KAAKC,qBAAlD,EAAyE,GAAGN,YAA5E;;QACA,KAAKM,qBAAL,GAA6BN,YAAY,CAACO,MAA1C;QACA,MAAMC,QAAQ,GAAGR,YAAY,CAACA,YAAY,CAACO,MAAb,GAAsB,CAAvB,CAA7B;QACA,MAAME,aAAa,GAAG,KAAKJ,mBAAL,GAA2BL,YAAY,CAACO,MAAxC,GAAiD,CAAvE;QACAL,GAAG,GAAG,IAAIQ,iBAAJ,CAAqBD,aAArB,EAAoCD,QAAQ,CAACG,IAAT,CAAcJ,MAAlD,CAAN;MACH;;MACD,IAAIN,KAAJ,EAAW;QACP,KAAKW,aAAL,GAAqB,IAArB;QACA,KAAKP,mBAAL,GAA2B,IAA3B;QACA,KAAKC,qBAAL,GAA6B,CAA7B;MACH,CAbkE,CAcnE;MACA;MACA;;;MACA,KAAKP,cAAL,CAAoBG,GAApB;IACH,CApNmG;IAChG,KAAKC,MAAL,GAAcN,KAAd;IACA,KAAKgB,YAAL,GAAoBf,WAApB;IACA,KAAKgB,iBAAL,GAAyB,IAAzB;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;EACWC,oBAAoB,CAACD,iBAAD,EAA6C;IACpE,KAAKA,iBAAL,GAAyBA,iBAAzB;EACH;EAED;AACJ;AACA;AACA;;;EACWE,iBAAiB,CAACjB,cAAD,EAAuC;IAC3D,KAAKA,cAAL,GAAsBA,cAAtB;EACH;;EAEqB,IAAXD,WAAW,GAAgB;IAClC,OAAO,KAAKe,YAAZ;EACH;;EAEiB,IAAPI,OAAO,GAAY;IAC1B,OAAO,KAAKd,MAAL,CAAYe,MAAZ,CAAmB,CAACC,GAAD,EAAMC,IAAN,KAAeD,GAAG,GAAGC,IAAI,CAACT,IAAL,CAAUJ,MAAlD,EAA0D,CAA1D,MAAiE,CAAxE;EACH;;EAEMc,KAAK,GAAgB;IACxB,MAAMC,WAAW,GAAG,KAAKzB,KAAL,CAAW0B,GAAX,CAAeC,CAAC,IAAI,KAAK1B,WAAL,CAAiB2B,eAAjB,CAAiCD,CAAC,CAACE,SAAF,EAAjC,CAApB,CAApB;IACA,OAAO,IAAI/B,WAAJ,CAAgB2B,WAAhB,EAA6B,KAAKT,YAAlC,EAAgD,KAAKd,cAArD,CAAP;EACH;;EAEO4B,UAAU,CAACC,KAAD,EAAgBR,IAAhB,EAAkC;IAChD,KAAKjB,MAAL,CAAYC,MAAZ,CAAmBwB,KAAnB,EAA0B,CAA1B,EAA6BR,IAA7B;;IACA,IAAI,KAAKS,aAAL,IAAsBD,KAA1B,EAAiC;MAC7B,EAAE,KAAKC,aAAP;IACH;;IACD,IAAI,KAAKxB,mBAAL,IAA4BuB,KAAhC,EAAuC;MACnC,EAAE,KAAKvB,mBAAP;IACH;EACJ;;EAEOyB,UAAU,CAACF,KAAD,EAAsB;IACpC,KAAKzB,MAAL,CAAYC,MAAZ,CAAmBwB,KAAnB,EAA0B,CAA1B;;IACA,IAAIA,KAAK,KAAK,KAAKC,aAAnB,EAAkC;MAC9B,KAAKA,aAAL,GAAqB,IAArB;IACH,CAFD,MAEO,IAAI,KAAKA,aAAL,GAAqBD,KAAzB,EAAgC;MACnC,EAAE,KAAKC,aAAP;IACH;;IACD,IAAID,KAAK,KAAK,KAAKvB,mBAAnB,EAAwC;MACpC,KAAKA,mBAAL,GAA2B,IAA3B;IACH,CAFD,MAEO,IAAI,KAAKA,mBAAL,GAA2BuB,KAA/B,EAAsC;MACzC,EAAE,KAAKvB,mBAAP;IACH;EACJ;;EAEO0B,WAAW,CAACH,KAAD,EAAgBR,IAAhB,EAAkC;IACjD,KAAKjB,MAAL,CAAYC,MAAZ,CAAmBwB,KAAnB,EAA0B,CAA1B,EAA6BR,IAA7B;EACH;;EAEe,IAALvB,KAAK,GAAW;IACvB,OAAO,KAAKM,MAAZ;EACH;;EAEsB,IAAZ6B,YAAY,GAA6B;IAChD,IAAI,KAAKH,aAAL,KAAuB,KAAKxB,mBAAhC,EAAqD;MACjD,OAAO,KAAKO,aAAZ;IACH;;IACD,OAAO,IAAP;EACH;;EAEMqB,gBAAgB,GAAqB;IACxC,IAAI,KAAK9B,MAAL,CAAYI,MAAhB,EAAwB;MACpB,MAAMqB,KAAK,GAAG,KAAKzB,MAAL,CAAYI,MAAZ,GAAqB,CAAnC;MACA,MAAMa,IAAI,GAAG,KAAKjB,MAAL,CAAYyB,KAAZ,CAAb;MACA,OAAO,IAAIlB,iBAAJ,CAAqBkB,KAArB,EAA4BR,IAAI,CAACT,IAAL,CAAUJ,MAAtC,CAAP;IACH,CAJD,MAIO;MACH;MACA,OAAO,IAAIG,iBAAJ,CAAqB,CAAC,CAAtB,EAAyB,CAAzB,CAAP;IACH;EACJ;;EAEMwB,cAAc,GAAqB;IACtC,OAAO,KAAK/B,MAAL,CAAYoB,GAAZ,CAAgBC,CAAC,IAAIA,CAAC,CAACE,SAAF,EAArB,CAAP;EACH;;EAEOS,IAAI,CAACC,QAAD,EAAmBC,SAAnB,EAAsCC,KAAtC,EAAoE;IAC5E,MAAMC,aAAa,GAAG,KAAK1C,KAAL,CAAWqB,MAAX,CAAkB,CAACP,IAAD,EAAOa,CAAP,KAAab,IAAI,GAAGa,CAAC,CAACb,IAAxC,EAA8C,EAA9C,CAAtB,CAD4E,CAE5E;;IACA,IAAI0B,SAAS,KAAK,cAAlB,EAAkC;MAC9B,OAAO,IAAAG,kBAAA,EAAaD,aAAb,EAA4BH,QAA5B,CAAP;IACH,CAFD,MAEO;MACH,OAAO,IAAAK,iBAAA,EAAYF,aAAZ,EAA2BH,QAA3B,EAAqCE,KAAK,CAACI,MAA3C,CAAP;IACH;EACJ;;EAEMC,KAAK,CAACC,eAAD,EAAoCN,KAApC,EAAmDD,SAAnD,EAA6E;IACrF,KAAKlC,MAAL,GAAcyC,eAAe,CAACrB,GAAhB,CAAoBC,CAAC,IAAI,KAAKX,YAAL,CAAkBY,eAAlB,CAAkCD,CAAlC,CAAzB,CAAd;;IACA,IAAI,CAACc,KAAL,EAAY;MACRA,KAAK,GAAG,KAAKL,gBAAL,EAAR;IACH,CAJoF,CAKrF;IACA;IACA;;;IACA,IAAI,KAAKrB,aAAT,EAAwB;MACpB,KAAKA,aAAL,GAAqB,IAArB;MACA,KAAKP,mBAAL,GAA2B,IAA3B;IACH;;IACD,KAAKN,cAAL,CAAoBuC,KAApB,EAA2BD,SAA3B;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;EACWQ,MAAM,CAAChD,KAAD,EAAgBiD,QAAhB,EAA6C;IACtD,MAAMC,WAAW,GAAG,KAAKC,OAAL,CAAaF,QAAb,CAApB;IACA,IAAIG,aAAa,GAAG,CAApB;;IACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGrD,KAAK,CAACU,MAA1B,EAAkC,EAAE2C,CAApC,EAAuC;MACnC,MAAM9B,IAAI,GAAGvB,KAAK,CAACqD,CAAD,CAAlB;MACAD,aAAa,IAAI7B,IAAI,CAACT,IAAL,CAAUJ,MAA3B;MACA,KAAKoB,UAAL,CAAgBoB,WAAW,GAAGG,CAA9B,EAAiC9B,IAAjC;IACH;;IACD,OAAO6B,aAAP;EACH;;EAEME,MAAM,CAACf,QAAD,EAAmBC,SAAnB,EAAsCC,KAAtC,EAA4E;IACrF,MAAMH,IAAI,GAAG,KAAKA,IAAL,CAAUC,QAAV,EAAoBC,SAApB,EAA+BC,KAA/B,CAAb;IACA,MAAMQ,QAAQ,GAAG,KAAKM,iBAAL,CAAuBjB,IAAI,CAACkB,EAA5B,EAAgCf,KAAK,CAACgB,SAAtC,CAAjB;IACA,IAAIC,qBAAqB,GAAG,CAA5B;;IACA,IAAIpB,IAAI,CAACqB,OAAT,EAAkB;MACdD,qBAAqB,GAAG,KAAKE,UAAL,CAAgBX,QAAhB,EAA0BX,IAAI,CAACqB,OAAL,CAAajD,MAAvC,CAAxB;IACH;;IACD,IAAImD,QAAQ,GAAG,CAAf;;IACA,IAAIvB,IAAI,CAACwB,KAAT,EAAgB;MACZD,QAAQ,GAAG,KAAKE,OAAL,CAAad,QAAb,EAAuBX,IAAI,CAACwB,KAA5B,EAAmCtB,SAAnC,CAAX;IACH;;IACD,KAAKwB,kBAAL;IACA,MAAMC,WAAW,GAAG3B,IAAI,CAACkB,EAAL,GAAUE,qBAAV,GAAkCG,QAAtD;IACA,IAAIK,WAAW,GAAG,KAAKX,iBAAL,CAAuBU,WAAvB,EAAoC,IAApC,CAAlB;IACA,MAAME,mBAAmB,GAAG3B,SAAS,KAAK,iBAAd,IAAmCA,SAAS,KAAK,gBAA7E;IACA,MAAM4B,SAAS,GAAG,KAAKC,aAAL,CAAmBH,WAAnB,EAAgCC,mBAAhC,CAAlB;;IACA,IAAI,KAAKlD,iBAAT,EAA4B;MACxB,MAAMqD,iBAAiB,GAAG,KAAKC,oBAAL,CAA0BL,WAA1B,EAAuC1B,SAAvC,EAAkDF,IAAlD,CAA1B;MACA4B,WAAW,GAAG,KAAKX,iBAAL,CAAuBU,WAAW,GAAGK,iBAArC,EAAwD,IAAxD,CAAd;IACH;;IACD,KAAKpE,cAAL,CAAoBgE,WAApB,EAAiC1B,SAAjC,EAA4CF,IAA5C;IACA,OAAO8B,SAAP;EACH;;EAEOG,oBAAoB,CAACL,WAAD,EAAgC1B,SAAhC,EAAmDF,IAAnD,EAAwE;IAChG,MAAMkC,MAAM,GAAG,KAAKvD,iBAAL,CAAuBiD,WAAvB,EAAoC1B,SAApC,EAA+CF,IAA/C,CAAf;IACA,OAAOmC,MAAM,CAACC,QAAP,CAAgBF,MAAhB,IAA0BA,MAA1B,GAA6C,CAApD;EACH;;EAEOH,aAAa,CAAChE,GAAD,EAAwB8D,mBAAxB,EAAqE;IACtF,MAAM;MAAEpC;IAAF,IAAY1B,GAAlB;IACA,MAAMkB,IAAI,GAAG,KAAKjB,MAAL,CAAYyB,KAAZ,CAAb;;IACA,IAAIR,IAAJ,EAAU;MACN,IAAIQ,KAAK,KAAK,KAAKC,aAAnB,EAAkC;QAC9B,KAAKA,aAAL,GAAqBD,KAArB;;QACA,IAAIoC,mBAAmB,IAAI,KAAKnC,aAAL,KAAuB,KAAKxB,mBAAvD,EAA4E;UACxE;UACA,MAAMmE,EAAE,GAAGpD,IAAI,CAACqD,kBAAL,CAAwB,KAAKC,cAA7B,CAAX;;UACA,IAAIF,EAAJ,EAAQ;YACJ;YACA,KAAK5D,aAAL,GAAqB4D,EAArB;YACA,KAAKnE,mBAAL,GAA2BuB,KAA3B;YACA,KAAKtB,qBAAL,GAA6B,CAA7B;UACH;QACJ;MACJ,CAbK,CAcN;;;MACA,IAAI,KAAK0B,YAAT,EAAuB;QACnB,OAAO,KAAKA,YAAL,CAAkB2C,YAAlB,CAA+BvD,IAA/B,EAAqClB,GAArC,CAAP;MACH;IACJ,CAlBD,MAkBO;MACH,KAAK2B,aAAL,GAAqB,IAArB;MACA,KAAKjB,aAAL,GAAqB,IAArB;MACA,KAAKP,mBAAL,GAA2B,IAA3B;MACA,KAAKC,qBAAL,GAA6B,CAA7B;IACH;;IACD,OAAOsE,OAAO,CAACC,OAAR,EAAP;EACH;;EAsBOhB,kBAAkB,GAAS;IAC/B,IAAIiB,QAAJ;;IACA,KAAK,IAAI5B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK/C,MAAL,CAAYI,MAAhC,EAAwC,EAAE2C,CAA1C,EAA6C;MACzC,IAAI9B,IAAI,GAAG,KAAKjB,MAAL,CAAY+C,CAAZ,CAAX;MACA,MAAMjC,OAAO,GAAG,CAACG,IAAI,CAACT,IAAL,CAAUJ,MAA3B;MACA,MAAMwE,QAAQ,GAAG,CAAC9D,OAAD,IAAY6D,QAAZ,IAAwBA,QAAQ,CAACE,KAAT,CAAe5D,IAAf,CAAzC;;MACA,IAAIH,OAAO,IAAI8D,QAAf,EAAyB;QACrB;QACA3D,IAAI,GAAG0D,QAAP;QACA,KAAKhD,UAAL,CAAgBoB,CAAhB,EAHqB,CAIrB;;QACA,EAAEA,CAAF;MACH;;MACD4B,QAAQ,GAAG1D,IAAX;IACH;EACJ;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;EACWqC,UAAU,CAACvD,GAAD,EAAiBiB,GAAjB,EAAsC;IACnD,IAAI;MAAES,KAAF;MAASc;IAAT,IAAoBxC,GAAxB;IACA,IAAIqD,qBAAqB,GAAG,CAA5B;;IACA,OAAOpC,GAAG,GAAG,CAAb,EAAgB;MACZ;MACA,IAAIC,IAAI,GAAG,KAAKjB,MAAL,CAAYyB,KAAZ,CAAX;MACA,MAAMqD,MAAM,GAAGC,IAAI,CAACC,GAAL,CAAShE,GAAT,EAAcC,IAAI,CAACT,IAAL,CAAUJ,MAAV,GAAmBmC,MAAjC,CAAf,CAHY,CAIZ;;MACA,IAAIuC,MAAJ,EAAY;QACR,IAAI7D,IAAI,CAACgE,OAAT,EAAkB;UACd,MAAMC,WAAW,GAAGjE,IAAI,CAACkE,MAAL,CAAY5C,MAAZ,EAAoBuC,MAApB,CAApB;;UACA,IAAI,OAAOI,WAAP,KAAuB,QAA3B,EAAqC;YACjC,KAAKtD,WAAL,CAAiBH,KAAjB,EAAwB,KAAKf,YAAL,CAAkB0E,iBAAlB,CAAoCF,WAApC,CAAxB;UACH;;UACDjE,IAAI,GAAG,KAAKjB,MAAL,CAAYyB,KAAZ,CAAP,CALc,CAMd;;UACA,IAAI,CAACR,IAAI,CAACT,IAAL,CAAUJ,MAAf,EAAuB;YACnB,KAAKuB,UAAL,CAAgBF,KAAhB;UACH,CAFD,MAEO;YACHA,KAAK,IAAI,CAAT;UACH;QACJ,CAZD,MAYO;UACH2B,qBAAqB,IAAIb,MAAzB;UACA,KAAKZ,UAAL,CAAgBF,KAAhB;QACH;MACJ,CAjBD,MAiBO;QACHA,KAAK,IAAI,CAAT;MACH;;MACDT,GAAG,IAAI8D,MAAP;MACAvC,MAAM,GAAG,CAAT;IACH;;IACD,OAAOa,qBAAP;EACH,CAvR4B,CAyR7B;;;EACQP,OAAO,CAAC9C,GAAD,EAAyB;IACpC,IAAIA,GAAG,CAAC0B,KAAJ,KAAc,CAAC,CAAnB,EAAsB;MAClB,OAAO,CAAP;IACH;;IACD,IAAI1B,GAAG,CAACwC,MAAJ,KAAe,CAAnB,EAAsB;MAClB,OAAOxC,GAAG,CAAC0B,KAAX;IACH;;IACD,MAAMR,IAAI,GAAG,KAAKjB,MAAL,CAAYD,GAAG,CAAC0B,KAAhB,CAAb;;IACA,IAAI1B,GAAG,CAACwC,MAAJ,IAActB,IAAI,CAACT,IAAL,CAAUJ,MAA5B,EAAoC;MAChC,OAAOL,GAAG,CAAC0B,KAAJ,GAAY,CAAnB;IACH;;IAED,MAAM4D,UAAU,GAAGpE,IAAI,CAACqE,KAAL,CAAWvF,GAAG,CAACwC,MAAf,CAAnB;IACA,KAAKf,UAAL,CAAgBzB,GAAG,CAAC0B,KAAJ,GAAY,CAA5B,EAA+B4D,UAA/B;IACA,OAAOtF,GAAG,CAAC0B,KAAJ,GAAY,CAAnB;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;EACYgC,OAAO,CAAC1D,GAAD,EAAiBwF,GAAjB,EAA8BrD,SAA9B,EAAyD;IACpE,IAAI;MAAET;IAAF,IAAY1B,GAAhB;IACA,MAAM;MAAEwC;IAAF,IAAaxC,GAAnB;IACA,IAAIyF,MAAM,GAAGD,GAAG,CAACnF,MAAjB;IACA,MAAMa,IAAI,GAAG,KAAKjB,MAAL,CAAYyB,KAAZ,CAAb;;IACA,IAAIR,IAAJ,EAAU;MACN,IAAIA,IAAI,CAACgE,OAAT,EAAkB;QACd,IAAIhE,IAAI,CAACwE,iBAAL,CAAuBlD,MAAvB,EAA+BgD,GAA/B,EAAoCrD,SAApC,CAAJ,EAAoD;UAChDqD,GAAG,GAAG,IAAN;QACH,CAFD,MAEO;UACH,MAAMG,SAAS,GAAGzE,IAAI,CAACqE,KAAL,CAAW/C,MAAX,CAAlB;UACAd,KAAK,IAAI,CAAT;UACA,KAAKD,UAAL,CAAgBC,KAAhB,EAAuBiE,SAAvB;QACH;MACJ,CARD,MAQO,IAAInD,MAAM,KAAK,CAAf,EAAkB;QACrB;QACA;QACAiD,MAAM,IAAIvE,IAAI,CAACT,IAAL,CAAUJ,MAAV,GAAmBmC,MAA7B;QACAd,KAAK,IAAI,CAAT;MACH;IACJ,CAfD,MAeO,IAAIA,KAAK,GAAG,CAAZ,EAAe;MAClB;MACA;MACAA,KAAK,GAAG,CAAR;IACH;;IACD,OAAO8D,GAAP,EAAY;MACR,MAAMI,OAAO,GAAG,KAAKjF,YAAL,CAAkBkF,kBAAlB,CAAqCL,GAArC,EAA0C9D,KAA1C,EAAiDS,SAAjD,CAAhB;;MACA,MAAM2D,MAAM,GAAGN,GAAf;MACAA,GAAG,GAAGI,OAAO,CAACG,mBAAR,CAA4BP,GAA5B,EAAiCrD,SAAjC,CAAN;;MACA,IAAIqD,GAAG,KAAKM,MAAZ,EAAoB;QAChB;QACAE,OAAO,CAACC,KAAR,CAAe,yCAAwCT,GAAI,WAAUrD,SAAU,GAA/E;QACA;MACH;;MACD,KAAKV,UAAL,CAAgBC,KAAhB,EAAuBkE,OAAvB;MACAlE,KAAK,IAAI,CAAT;IACH;;IACD,OAAO+D,MAAP;EACH;;EAEMvC,iBAAiB,CAACgD,WAAD,EAA2D;IAAA,IAArCC,SAAqC,uEAAzB,KAAyB;IAC/E,IAAIC,aAAa,GAAG,CAApB;;IACA,MAAM1E,KAAK,GAAG,KAAKzB,MAAL,CAAYoG,SAAZ,CAAsBnF,IAAI,IAAI;MACxC,MAAMoF,OAAO,GAAGpF,IAAI,CAACT,IAAL,CAAUJ,MAA1B;;MACA,IACK8F,SAAS,IAAKC,aAAa,GAAGE,OAAjB,IAA6BJ,WAA3C,IACC,CAACC,SAAD,IAAeC,aAAa,GAAGE,OAAjB,GAA4BJ,WAF/C,EAGE;QACE,OAAO,IAAP;MACH;;MACDE,aAAa,IAAIE,OAAjB;MACA,OAAO,KAAP;IACH,CAVa,CAAd;;IAWA,IAAI5E,KAAK,KAAK,CAAC,CAAf,EAAkB;MACd,OAAO,KAAKK,gBAAL,EAAP;IACH,CAFD,MAEO;MACH,OAAO,IAAIvB,iBAAJ,CAAqBkB,KAArB,EAA4BwE,WAAW,GAAGE,aAA1C,CAAP;IACH;EACJ;EAED;AACJ;AACA;AACA;AACA;AACA;;;EACWG,UAAU,CAACC,SAAD,EAA4D;IAAA,IAA9BC,SAA8B,uEAAlBD,SAAkB;IACzE,OAAO,IAAIE,cAAJ,CAAU,IAAV,EAAgBF,SAAhB,EAA2BC,SAA3B,CAAP;EACH;;EAEME,YAAY,CAACC,aAAD,EAAkCC,WAAlC,EAAiElH,KAAjE,EAAsF;IACrG;IACA;IACA,MAAMmH,SAAS,GAAGD,WAAW,CAACE,QAAZ,CAAqB,IAArB,CAAlB;IACA,MAAMC,iBAAiB,GAAG,KAAKlE,OAAL,CAAa8D,aAAb,CAA1B,CAJqG,CAKrG;;IACAC,WAAW,GAAGC,SAAS,CAACG,UAAV,CAAqB,IAArB,CAAd;IACA,MAAMC,eAAe,GAAG,KAAKpE,OAAL,CAAa+D,WAAb,CAAxB;;IACA,KAAK,IAAI7D,CAAC,GAAGkE,eAAe,GAAG,CAA/B,EAAkClE,CAAC,IAAIgE,iBAAvC,EAA0D,EAAEhE,CAA5D,EAA+D;MAC3D,KAAKpB,UAAL,CAAgBoB,CAAhB;IACH;;IACD,IAAImE,SAAS,GAAGH,iBAAhB;;IACA,KAAK,MAAM9F,IAAX,IAAmBvB,KAAnB,EAA0B;MACtB,KAAK8B,UAAL,CAAgB0F,SAAhB,EAA2BjG,IAA3B;MACAiG,SAAS,IAAI,CAAb;IACH;;IACD,KAAKxD,kBAAL;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;;;EACWyD,SAAS,CAACC,QAAD,EAAmD;IAC/D,MAAMrH,GAAG,GAAGqH,QAAQ,EAApB;IACA,IAAItD,SAAwB,GAAG,IAA/B;;IACA,IAAI,EAAE/D,GAAG,YAAY0G,cAAjB,CAAJ,EAA6B;MACzB3C,SAAS,GAAG,KAAKC,aAAL,CAAmBhE,GAAnB,EAAwB,IAAxB,CAAZ;IACH,CAFD,MAEO;MACH+D,SAAS,GAAGW,OAAO,CAACC,OAAR,EAAZ;IACH;;IACD,KAAK9E,cAAL,CAAoBG,GAApB;IACA,OAAO+D,SAAP;EACH;;AA5Z4B"}