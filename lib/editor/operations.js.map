{"version":3,"file":"operations.js","names":["formatRange","range","action","wasInitializedEmpty","selectRangeOfWordAtCaret","trim","length","Formatting","Bold","toggleInlineFormat","Italics","Strikethrough","Code","formatRangeAsCode","Quote","formatRangeAsQuote","InsertLink","formatRangeAsLink","replaceRangeAndExpandSelection","newParts","model","transform","oldLen","addedLen","replace","firstOffset","start","asOffset","lastOffset","add","startRange","asPosition","replaceRangeAndMoveCaret","offset","atNodeEnd","replaceRangeAndAutoAdjustCaret","rangeHasFormatting","prefixLength","suffixLength","lastStartingPosition","getLastStartingPosition","relativeOffset","distanceFromEnd","offsetDirection","Math","sign","atEnd","isFormattable","_index","part","text","type","Type","Plain","expandForwardsWhile","expandBackwardsWhile","rangeStartsAtBeginningOfLine","startsWithPartial","isFirstPart","index","previousIsNewline","parts","Newline","rangeEndsAtEndOfLine","lastPart","end","endsWithPartial","isLastPart","nextIsNewline","partCreator","i","splice","plain","unshift","newline","push","hasBlockFormatting","startsWith","endsWith","includes","needsBlockFormatting","some","p","shift","pop","fenceLen","longestBacktickSequence","hasInlineFormatting","repeat","linkRegex","isFormattedAsLink","test","linkDescription","isBlank","isNL","prefix","suffix","paragraphIndexes","startIndex","lastNonEmptyPart","map","lastIndexOf","forEach","startIdx","endIdx","base","isFormatted","partWithoutPrefix","serialize","slice","deserializePart","partWithoutSuffix","suffixPartText","substring","hasFormatting"],"sources":["../../src/editor/operations.ts"],"sourcesContent":["/*\nCopyright 2019 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport Range from \"./range\";\nimport { Part, Type } from \"./parts\";\nimport { Formatting } from \"../components/views/rooms/MessageComposerFormatBar\";\nimport { longestBacktickSequence } from './deserialize';\n\n/**\n * Some common queries and transformations on the editor model\n */\n\n/**\n * Formats a given range with a given action\n * @param {Range} range the range that should be formatted\n * @param {Formatting} action the action that should be performed on the range\n */\nexport function formatRange(range: Range, action: Formatting): void {\n    // If the selection was empty we select the current word instead\n    if (range.wasInitializedEmpty()) {\n        selectRangeOfWordAtCaret(range);\n    } else {\n        // Remove whitespace or new lines in our selection\n        range.trim();\n    }\n\n    // Edge case when just selecting whitespace or new line.\n    // There should be no reason to format whitespace, so we can just return.\n    if (range.length === 0) {\n        return;\n    }\n\n    switch (action) {\n        case Formatting.Bold:\n            toggleInlineFormat(range, \"**\");\n            break;\n        case Formatting.Italics:\n            toggleInlineFormat(range, \"_\");\n            break;\n        case Formatting.Strikethrough:\n            toggleInlineFormat(range, \"<del>\", \"</del>\");\n            break;\n        case Formatting.Code:\n            formatRangeAsCode(range);\n            break;\n        case Formatting.Quote:\n            formatRangeAsQuote(range);\n            break;\n        case Formatting.InsertLink:\n            formatRangeAsLink(range);\n            break;\n    }\n}\n\nexport function replaceRangeAndExpandSelection(range: Range, newParts: Part[]): void {\n    const { model } = range;\n    model.transform(() => {\n        const oldLen = range.length;\n        const addedLen = range.replace(newParts);\n        const firstOffset = range.start.asOffset(model);\n        const lastOffset = firstOffset.add(oldLen + addedLen);\n        return model.startRange(firstOffset.asPosition(model), lastOffset.asPosition(model));\n    });\n}\n\nexport function replaceRangeAndMoveCaret(range: Range, newParts: Part[], offset = 0, atNodeEnd = false): void {\n    const { model } = range;\n    model.transform(() => {\n        const oldLen = range.length;\n        const addedLen = range.replace(newParts);\n        const firstOffset = range.start.asOffset(model);\n        const lastOffset = firstOffset.add(oldLen + addedLen + offset, atNodeEnd);\n        return lastOffset.asPosition(model);\n    });\n}\n\n/**\n * Replaces a range with formatting or removes existing formatting and\n * positions the cursor with respect to the prefix and suffix length.\n * @param {Range} range the previous value\n * @param {Part[]} newParts the new value\n * @param {boolean} rangeHasFormatting the new value\n * @param {number} prefixLength the length of the formatting prefix\n * @param {number} suffixLength the length of the formatting suffix, defaults to prefix length\n */\nexport function replaceRangeAndAutoAdjustCaret(\n    range: Range,\n    newParts: Part[],\n    rangeHasFormatting = false,\n    prefixLength: number,\n    suffixLength = prefixLength,\n): void {\n    const { model } = range;\n    const lastStartingPosition = range.getLastStartingPosition();\n    const relativeOffset = lastStartingPosition.offset - range.start.offset;\n    const distanceFromEnd = range.length - relativeOffset;\n    // Handle edge case where the caret is located within the suffix or prefix\n    if (rangeHasFormatting) {\n        if (relativeOffset < prefixLength) { // Was the caret at the left format string?\n            replaceRangeAndMoveCaret(range, newParts, -(range.length - 2 * suffixLength));\n            return;\n        }\n        if (distanceFromEnd < suffixLength) { // Was the caret at the right format string?\n            replaceRangeAndMoveCaret(range, newParts, 0, true);\n            return;\n        }\n    }\n    // Calculate new position with respect to the previous position\n    model.transform(() => {\n        const offsetDirection = Math.sign(range.replace(newParts)); // Compensates for shrinkage or expansion\n        const atEnd = distanceFromEnd === suffixLength;\n        return lastStartingPosition.asOffset(model).add(offsetDirection * prefixLength, atEnd).asPosition(model);\n    });\n}\n\nconst isFormattable = (_index: number, offset: number, part: Part) => {\n    return part.text[offset] !== \" \" && part.type === Type.Plain;\n};\n\nexport function selectRangeOfWordAtCaret(range: Range): void {\n    // Select right side of word\n    range.expandForwardsWhile(isFormattable);\n    // Select left side of word\n    range.expandBackwardsWhile(isFormattable);\n    // Trim possibly selected new lines\n    range.trim();\n}\n\nexport function rangeStartsAtBeginningOfLine(range: Range): boolean {\n    const { model } = range;\n    const startsWithPartial = range.start.offset !== 0;\n    const isFirstPart = range.start.index === 0;\n    const previousIsNewline = !isFirstPart && model.parts[range.start.index - 1].type === Type.Newline;\n    return !startsWithPartial && (isFirstPart || previousIsNewline);\n}\n\nexport function rangeEndsAtEndOfLine(range: Range): boolean {\n    const { model } = range;\n    const lastPart = model.parts[range.end.index];\n    const endsWithPartial = range.end.offset !== lastPart.text.length;\n    const isLastPart = range.end.index === model.parts.length - 1;\n    const nextIsNewline = !isLastPart && model.parts[range.end.index + 1].type === Type.Newline;\n    return !endsWithPartial && (isLastPart || nextIsNewline);\n}\n\nexport function formatRangeAsQuote(range: Range): void {\n    const { model, parts } = range;\n    const { partCreator } = model;\n    for (let i = 0; i < parts.length; ++i) {\n        const part = parts[i];\n        if (part.type === Type.Newline) {\n            parts.splice(i + 1, 0, partCreator.plain(\"> \"));\n        }\n    }\n    parts.unshift(partCreator.plain(\"> \"));\n    if (!rangeStartsAtBeginningOfLine(range)) {\n        parts.unshift(partCreator.newline());\n    }\n    if (!rangeEndsAtEndOfLine(range)) {\n        parts.push(partCreator.newline());\n    }\n    parts.push(partCreator.newline());\n    replaceRangeAndExpandSelection(range, parts);\n}\n\nexport function formatRangeAsCode(range: Range): void {\n    const { model, parts } = range;\n    const { partCreator } = model;\n\n    const hasBlockFormatting = (range.length > 0)\n        && range.text.startsWith(\"```\")\n        && range.text.endsWith(\"```\")\n        && range.text.includes('\\n');\n\n    const needsBlockFormatting = parts.some(p => p.type === Type.Newline);\n\n    if (hasBlockFormatting) {\n        parts.shift();\n        parts.pop();\n        if (parts[0]?.text === \"\\n\" && parts[parts.length - 1]?.text === \"\\n\") {\n            parts.shift();\n            parts.pop();\n        }\n    } else if (needsBlockFormatting) {\n        parts.unshift(partCreator.plain(\"```\"), partCreator.newline());\n        if (!rangeStartsAtBeginningOfLine(range)) {\n            parts.unshift(partCreator.newline());\n        }\n        parts.push(\n            partCreator.newline(),\n            partCreator.plain(\"```\"));\n        if (!rangeEndsAtEndOfLine(range)) {\n            parts.push(partCreator.newline());\n        }\n    } else {\n        const fenceLen = longestBacktickSequence(range.text);\n        const hasInlineFormatting = range.text.startsWith(\"`\") && range.text.endsWith(\"`\");\n        //if it's already formatted untoggle based on fenceLen which returns the max. num of backtick within a text else increase the fence backticks with a factor of 1.\n        toggleInlineFormat(range, \"`\".repeat(hasInlineFormatting ? fenceLen : fenceLen + 1));\n        return;\n    }\n\n    replaceRangeAndExpandSelection(range, parts);\n}\n\nexport function formatRangeAsLink(range: Range, text?: string) {\n    const { model } = range;\n    const { partCreator } = model;\n    const linkRegex = /\\[(.*?)]\\(.*?\\)/g;\n    const isFormattedAsLink = linkRegex.test(range.text);\n    if (isFormattedAsLink) {\n        const linkDescription = range.text.replace(linkRegex, \"$1\");\n        const newParts = [partCreator.plain(linkDescription)];\n        replaceRangeAndMoveCaret(range, newParts, 0);\n    } else {\n        // We set offset to -1 here so that the caret lands between the brackets\n        replaceRangeAndMoveCaret(range, [partCreator.plain(\"[\" + range.text + \"]\" + \"(\" + (text ?? \"\") + \")\")], -1);\n    }\n}\n\n// parts helper methods\nconst isBlank = part => !part.text || !/\\S/.test(part.text);\nconst isNL = part => part.type === Type.Newline;\n\nexport function toggleInlineFormat(range: Range, prefix: string, suffix = prefix): void {\n    const { model, parts } = range;\n    const { partCreator } = model;\n\n    // compute paragraph [start, end] indexes\n    const paragraphIndexes = [];\n    let startIndex = 0;\n\n    // start at i=2 because we look at i and up to two parts behind to detect paragraph breaks at their end\n    for (let i = 2; i < parts.length; i++) {\n        // paragraph breaks can be denoted in a multitude of ways,\n        // - 2 newline parts in sequence\n        // - newline part, plain(<empty or just spaces>), newline part\n\n        // bump startIndex onto the first non-blank after the paragraph ending\n        if (isBlank(parts[i - 2]) && isNL(parts[i - 1]) && !isNL(parts[i]) && !isBlank(parts[i])) {\n            startIndex = i;\n        }\n\n        // if at a paragraph break, store the indexes of the paragraph\n        if (isNL(parts[i - 1]) && isNL(parts[i])) {\n            paragraphIndexes.push([startIndex, i - 1]);\n            startIndex = i + 1;\n        } else if (isNL(parts[i - 2]) && isBlank(parts[i - 1]) && isNL(parts[i])) {\n            paragraphIndexes.push([startIndex, i - 2]);\n            startIndex = i + 1;\n        }\n    }\n\n    const lastNonEmptyPart = parts.map(isBlank).lastIndexOf(false);\n    // If we have not yet included the final paragraph then add it now\n    if (startIndex <= lastNonEmptyPart) {\n        paragraphIndexes.push([startIndex, lastNonEmptyPart + 1]);\n    }\n\n    // keep track of how many things we have inserted as an offset:=0\n    let offset = 0;\n    paragraphIndexes.forEach(([startIdx, endIdx]) => {\n        // for each paragraph apply the same rule\n        const base = startIdx + offset;\n        const index = endIdx + offset;\n\n        const isFormatted = (index - base > 0) &&\n            parts[base].text.startsWith(prefix) &&\n            parts[index - 1].text.endsWith(suffix);\n\n        if (isFormatted) {\n            // remove prefix and suffix formatting string\n            const partWithoutPrefix = parts[base].serialize();\n            partWithoutPrefix.text = partWithoutPrefix.text.slice(prefix.length);\n            parts[base] = partCreator.deserializePart(partWithoutPrefix);\n\n            const partWithoutSuffix = parts[index - 1].serialize();\n            const suffixPartText = partWithoutSuffix.text;\n            partWithoutSuffix.text = suffixPartText.substring(0, suffixPartText.length - suffix.length);\n            parts[index - 1] = partCreator.deserializePart(partWithoutSuffix);\n        } else {\n            parts.splice(index, 0, partCreator.plain(suffix)); // splice in the later one first to not change offset\n            parts.splice(base, 0, partCreator.plain(prefix));\n            offset += 2; // offset index to account for the two items we just spliced in\n        }\n    });\n\n    // If the user didn't select something initially, we want to just restore\n    // the caret position instead of making a new selection.\n    if (range.wasInitializedEmpty() && prefix === suffix) {\n        // Check if we need to add a offset for a toggle or untoggle\n        const hasFormatting = range.text.startsWith(prefix) && range.text.endsWith(suffix);\n        replaceRangeAndAutoAdjustCaret(range, parts, hasFormatting, prefix.length);\n    } else {\n        replaceRangeAndExpandSelection(range, parts);\n    }\n}\n"],"mappings":"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"}