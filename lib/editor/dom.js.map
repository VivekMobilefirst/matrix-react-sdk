{"version":3,"file":"dom.js","names":["walkDOMDepthFirst","rootNode","enterNodeCallback","leaveNodeCallback","node","firstChild","shouldDescend","nextSibling","parentElement","getCaretOffsetAndText","editor","sel","offset","text","getSelectionOffsetAndText","focusNode","focusOffset","caret","tryReduceSelectionToTextNode","selectionNode","selectionOffset","nodeType","Node","ELEMENT_NODE","childNodeCount","childNodes","length","lastChild","TEXT_NODE","textContent","Number","MAX_SAFE_INTEGER","characterOffset","offsetToNode","getTextAndOffsetToNode","getCaret","offsetWithinNode","DocumentOffset","atNodeEnd","isCaretNode","zwsIdx","nodeValue","indexOf","CARET_NODE_CHAR","foundNode","tagName","nodeText","getTextNodeValue","replace","getRangeForSelection","model","selection","anchorOffset","anchorNode","focusPosition","asPosition","anchorPosition","startRange"],"sources":["../../src/editor/dom.ts"],"sourcesContent":["/*\nCopyright 2019 New Vector Ltd\nCopyright 2019 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { CARET_NODE_CHAR, isCaretNode } from \"./render\";\nimport DocumentOffset from \"./offset\";\nimport EditorModel from \"./model\";\nimport Range from \"./range\";\n\ntype Predicate = (node: Node) => boolean;\ntype Callback = (node: Node) => void;\n\nexport function walkDOMDepthFirst(rootNode: Node, enterNodeCallback: Predicate, leaveNodeCallback: Callback) {\n    let node = rootNode.firstChild;\n    while (node && node !== rootNode) {\n        const shouldDescend = enterNodeCallback(node);\n        if (shouldDescend && node.firstChild) {\n            node = node.firstChild;\n        } else if (node.nextSibling) {\n            node = node.nextSibling;\n        } else {\n            while (!node.nextSibling && node !== rootNode) {\n                node = node.parentElement;\n                if (node !== rootNode) {\n                    leaveNodeCallback(node);\n                }\n            }\n            if (node !== rootNode) {\n                node = node.nextSibling;\n            }\n        }\n    }\n}\n\nexport function getCaretOffsetAndText(editor: HTMLDivElement, sel: Selection) {\n    const { offset, text } = getSelectionOffsetAndText(editor, sel.focusNode, sel.focusOffset);\n    return { caret: offset, text };\n}\n\nfunction tryReduceSelectionToTextNode(selectionNode: Node, selectionOffset: number) {\n    // if selectionNode is an element, the selected location comes after the selectionOffset-th child node,\n    // which can point past any childNode, in which case, the end of selectionNode is selected.\n    // we try to simplify this to point at a text node with the offset being\n    // a character offset within the text node\n    // Also see https://developer.mozilla.org/en-US/docs/Web/API/Selection\n    while (selectionNode && selectionNode.nodeType === Node.ELEMENT_NODE) {\n        const childNodeCount = selectionNode.childNodes.length;\n        if (childNodeCount) {\n            if (selectionOffset >= childNodeCount) {\n                selectionNode = selectionNode.lastChild;\n                if (selectionNode.nodeType === Node.TEXT_NODE) {\n                    selectionOffset = selectionNode.textContent.length;\n                } else {\n                    // this will select the last child node in the next iteration\n                    selectionOffset = Number.MAX_SAFE_INTEGER;\n                }\n            } else {\n                selectionNode = selectionNode.childNodes[selectionOffset];\n                // this will select the first child node in the next iteration\n                selectionOffset = 0;\n            }\n        } else {\n            // here node won't be a text node,\n            // but characterOffset should be 0,\n            // this happens under some circumstances\n            // when the editor is empty.\n            // In this case characterOffset=0 is the right thing to do\n            break;\n        }\n    }\n    return {\n        node: selectionNode,\n        characterOffset: selectionOffset,\n    };\n}\n\nfunction getSelectionOffsetAndText(editor: HTMLDivElement, selectionNode: Node, selectionOffset: number) {\n    const { node, characterOffset } = tryReduceSelectionToTextNode(selectionNode, selectionOffset);\n    const { text, offsetToNode } = getTextAndOffsetToNode(editor, node);\n    const offset = getCaret(node, offsetToNode, characterOffset);\n    return { offset, text };\n}\n\n// gets the caret position details, ignoring and adjusting to\n// the ZWS if you're typing in a caret node\nfunction getCaret(node: Node, offsetToNode: number, offsetWithinNode: number) {\n    // if no node is selected, return an offset at the start\n    if (!node) {\n        return new DocumentOffset(0, false);\n    }\n    let atNodeEnd = offsetWithinNode === node.textContent.length;\n    if (node.nodeType === Node.TEXT_NODE && isCaretNode(node.parentElement)) {\n        const zwsIdx = node.nodeValue.indexOf(CARET_NODE_CHAR);\n        if (zwsIdx !== -1 && zwsIdx < offsetWithinNode) {\n            offsetWithinNode -= 1;\n        }\n        // if typing in a caret node, you're either typing before or after the ZWS.\n        // In both cases, you should be considered at node end because the ZWS is\n        // not included in the text here, and once the model is updated and rerendered,\n        // that caret node will be removed.\n        atNodeEnd = true;\n    }\n    return new DocumentOffset(offsetToNode + offsetWithinNode, atNodeEnd);\n}\n\n// gets the text of the editor as a string,\n// and the offset in characters where the selectionNode starts in that string\n// all ZWS from caret nodes are filtered out\nfunction getTextAndOffsetToNode(editor: HTMLDivElement, selectionNode: Node) {\n    let offsetToNode = 0;\n    let foundNode = false;\n    let text = \"\";\n\n    function enterNodeCallback(node: HTMLElement) {\n        if (!foundNode) {\n            if (node === selectionNode) {\n                foundNode = true;\n            }\n        }\n        // usually newlines are entered as new DIV elements,\n        // but for example while pasting in some browsers, they are still\n        // converted to BRs, so also take these into account when they\n        // are not the last element in the DIV.\n        if (node.tagName === \"BR\" && node.nextSibling) {\n            if (!foundNode) {\n                offsetToNode += 1;\n            }\n            text += \"\\n\";\n        }\n        const nodeText = node.nodeType === Node.TEXT_NODE && getTextNodeValue(node);\n        if (nodeText) {\n            if (!foundNode) {\n                offsetToNode += nodeText.length;\n            }\n            text += nodeText;\n        }\n        return true;\n    }\n\n    function leaveNodeCallback(node: HTMLElement) {\n        // if this is not the last DIV (which are only used as line containers atm)\n        // we don't just check if there is a nextSibling because sometimes the caret ends up\n        // after the last DIV and it creates a newline if you type then,\n        // whereas you just want it to be appended to the current line\n        if (node.tagName === \"DIV\" && (<HTMLElement>node.nextSibling)?.tagName === \"DIV\") {\n            text += \"\\n\";\n            if (!foundNode) {\n                offsetToNode += 1;\n            }\n        }\n    }\n\n    walkDOMDepthFirst(editor, enterNodeCallback, leaveNodeCallback);\n\n    return { text, offsetToNode };\n}\n\n// get text value of text node, ignoring ZWS if it's a caret node\nfunction getTextNodeValue(node: Node): string {\n    const nodeText = node.nodeValue;\n    // filter out ZWS for caret nodes\n    if (isCaretNode(node.parentElement)) {\n        // typed in the caret node, so there is now something more in it than the ZWS\n        // so filter out the ZWS, and take the typed text into account\n        if (nodeText.length !== 1) {\n            return nodeText.replace(CARET_NODE_CHAR, \"\");\n        } else {\n            // only contains ZWS, which is ignored, so return empty string\n            return \"\";\n        }\n    } else {\n        return nodeText;\n    }\n}\n\nexport function getRangeForSelection(editor: HTMLDivElement, model: EditorModel, selection: Selection): Range {\n    const focusOffset = getSelectionOffsetAndText(\n        editor,\n        selection.focusNode,\n        selection.focusOffset,\n    ).offset;\n    const anchorOffset = getSelectionOffsetAndText(\n        editor,\n        selection.anchorNode,\n        selection.anchorOffset,\n    ).offset;\n    const focusPosition = focusOffset.asPosition(model);\n    const anchorPosition = anchorOffset.asPosition(model);\n    return model.startRange(focusPosition, anchorPosition);\n}\n"],"mappings":"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"}